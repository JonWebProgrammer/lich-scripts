##quiet
## vim: set ft=ruby:
=begin

    Modified by: JonWebProgrammer
    Note: Combined code from ;sloot, ;killcounter, and wrote some new code to go with it.

    SpiffyLoot by SpiffyJr

       todo: add auto-looting
     author: SpiffyJr
     name: SpiffyLoot
       tags: loot
    version: 3.3

    changelog:
        3.3 (2017-12-18)
            Attempting to fix phasing for sorcerors.
            Reorder changelog, new shit on top, duh.
        3.2 (2016-06-19)
            Updated the get_item and put_item code to not care about your container
        3.1 (2016-01-27)
            Added ability to try and sell boxes at pawn (useful for after a lockpick session if you keep mithril ones)
            Added ability to sell scarabs at the gemshop
        3.0 (2015-11-19)
            Add massive boulder skinning as a rolled up krynch sushi roll
=end

### TMP - bramble patch lewt
str = GameObj.type_data['gem'][:name].to_s

if str !~ /berry|thorn/
    GameObj.type_data['gem'][:name] = Regexp.new(str.sub('(?-mix:', '').sub(')$)', '|berry|thorn)$'))
    GameObj.sellable_data['gemshop'][:name] = Regexp.new(GameObj.sellable_data['gemshop'][:name].to_s.sub('(?-mix:', '').sub('$)', '|berry$|thorn$'))
end

str = GameObj.type_data['skin'][:name].to_s

if str !~ /shriveled cutting/
    GameObj.type_data['skin'][:name] = Regexp.new(GameObj.type_data['skin'][:name].to_s.sub('(?-mix:', '').sub(')s?$)', '|shriveled cutting|dessicated stem|frosted branch)s?$'))
    GameObj.sellable_data['furrier'][:name] = Regexp.new(GameObj.sellable_data['furrier'][:name].to_s.sub('(?-mix:', '').sub(')s?$)', '|shriveled cutting|dessicated stem|frosted branch)s?$'))
end
### TMP

putregex = /^You (?:put|(?:discreetly )?tuck|attempt to shield your|place|.* place|slip|wipe off the blade and sheathe|absent-mindedly drop|carefully add|find an incomplete bundle|untie your drawstring pouch)|^The .+ is already a bundle|^Your bundle would be too large if you if you tried to add that|^The .+ is too large to be bundled\.|^As you place your .+ inside your .+, you notice another .+ inside the .+ and carefully arrange the two .+ into a neat bundle\./

settings                   = CharSettings.to_hash

tracker = CharSettings['tracker'] ||= Array.new
loot_list = CharSettings['lootlist'] ||= Array.new
critterList = ""

creature_list=[["zombie rolton",1],["giant ant",1],["black-winged daggerbeak",1  ],["fire ant",1],["fanged rodent",1],["giant rat",1],["spotted gnarp",1],["young grass snake",1  ],["lesser ghoul",1],["black rolton",1],["mountain rolton",1],["carrion worm",1],["slimy little grub",1  ],["pale crab",2],["thyril",2],["spotted gak",2],["brown gak",2],["lesser frost shade",2  ],["cave gnome",2],["big ugly kobold",2],["moaning phantom",2],["sea nymph",2],["fanged goblin",2],["Mistydeep siren",2],["lesser shade",2],["rabid squirrel",2],["mountain snowcat",3  ],["kobold shepherd",3],["striped gak",3],["Bresnahanini rolton",3  ],["troglodyte",3],["cave gnoll",3],["striped relnak",3],["spotted velnalin",3  ],["greater ghoul",3],["white vysan",3],["greater ice spider",3  ],["dark vysan",3],["velnalin",3],["cave nipper",3],["ice skeleton",3],["relnak",3],["fire salamander",3],["water moccasin",4],["mongrel kobold",4],["urgh",4],["ridge orc",4],["fanged viper",4],["cobra",4],["spotted leaper",4],["black urgh",4],["whiptail",4],["revenant",4],["mongrel hobgoblin",5  ],["night golem",5],["mist wraith",5],["coyote",5],["bobcat",5],["water witch",5],["dark apparition",5],["nasty little gremlin",5  ],["spotted lynx",6],["monkey",6],["lesser orc",6],["lesser mummy",6],["snowy cockatrice",6  ],["leaper",6],["cockatrice",6],["firephantom",6],["spectral fisherman",6  ],["hobgoblin shaman",7  ],["blood eagle",7],["lesser burrow orc",7  ],["lesser red orc",7],["shelfae soldier",7],["greater kappa",7],["crystal crab",8],["mottled thrak",8],["greater orc",8],["greater spider",8],["albino tomb spider",8  ],["greater burrow orc",8  ],["bone golem",8],["crocodile",9],["brown spinner",9],["snow spectre",9],["death dirge",9],["rabid guard dog",10],["raider orc",10],["gnoll worker",10],["giant marmot",10],["cave worm",10],["werebear",10],["great boar",10],["wall guardian",11],["Neartofar orc",11],["shelfae chieftain",11 ],["dark orc",12],["crystal golem",12],["deranged sentry",13],["tawny brindlecat",13 ],["great stag",13],["plumed cockatrice",13 ],["gnoll thief",13],["darkwoode",13],["giant weasel",14],["black boar",14],["Agresh troll scout",14 ],["swamp troll",14],["shadowy spectre",14],["brown boar",14],["silverback orc",14],["great brown bear",14 ],["forest troll",14],["grey orc",14],["wolfshade",15],["ridgeback boar",15],["luminescent arachnid",15 ],["gnoll ranger",15],["Neartofar troll",15],["tomb wight",15],["black leopard",15],["arctic puma",15],["humpbacked puma",15],["panther",15],["large ogre",15],["puma",15],["red bear",16],["wind witch",16],["plains orc warrior",16 ],["mongrel wolfhound",16 ],["cave troll",16],["Agresh bear",16],["Agresh troll warrior",16 ],["phosphorescent worm",16 ],["mongrel troll",16],["fire guardian",16],["hill troll",16],["banded rattlesnake",16 ],["mountain ogre",16],["ghost wolf",16],["ghoul master",16],["fire rat",16],["black bear",16],["giant veaba",17],["mountain troll",17],["plains orc scout",17 ],["forest ogre",17],["gnoll guard",17],["plains ogre",17],["spiked cavern urchin",17 ],["black panther",17],["dark shambler",17],["mountain goat",17],["krolvin mercenary",17 ],["mountain lion",18],["nedum vereri",18],["cave lizard",18],["shelfae warlord",18],["rotting krolvin pirate",18 ],["thunder troll",18],["greenwing hornet",18 ],["ghostly warrior",18],["plains lion",18],["plains orc shaman",18 ],["bighorn sheep",18],["elder ghoul master",18 ],["war troll",18],["fire cat",18],["krolvin warrior",19],["striped warcat",20],["gnoll priest",20],["major spider",20],["ogre warrior",20],["Agresh troll chieftain",20 ],["wood wight",20],["massive grahnk",20],["steel golem",20],["arch wight",20],["cave bear",21],["plains orc chieftain",21 ],["ancient ghoul master",21 ],["Arachne servant",21],["crested basilisk",22 ],["cougar",22],["dark panther",22],["warthog",22],["nonomino",23],["niirsha",23],["fenghai",23],["crazed zombie",23],["rotting woodsman",23 ],["centaur",23],["Arachne acolyte",23],["tree viper",24],["giant albino scorpion",24 ],["arctic wolverine",24 ],["wolverine",24],["veteran reiver",24],["burly reiver",24],["ice hound",24],["carceris",25],["gnoll jarl",25],["krolvin warfarer",25 ],["spectral monk",25],["sacristan spirit",25],["Arachne priestess",26 ],["Arachne priest",26],["jungle troll",26],["tree spirit",26],["snow leopard",27],["Grutik savage",27],["troll chieftain",27],["cyclops",27],["lesser stone gargoyle",27 ],["monastic lich",27],["frenzied monk",27],["darken",28],["giant hawk-owl",28],["dobrem",28],["fire ogre",28],["ki-lin",28],["moaning spirit",28],["arctic manticore",29 ],["Grutik shaman",29],["pra'eda",29],["ice troll",29],["scaly burgee",29],["hunter troll",30],["hisskra warrior",30],["jungle troll chieftain",30 ],["elder tree spirit",30 ],["giant albino tomb spider",30],["mammoth arachnid",30 ],["hooded figure",30],["ash hag",31],["skeletal ice troll",31 ],["wild hound",31],["caribou",32],["ghostly mara",32],["rotting corpse",32],["rotting farmhand",32 ],["wild dog",32],["giant fog beetle",32 ],["ghostly pooka",33],["mezic",33],["three-toed tegu",33],["maw spore",33],["sand beetle",33],["hisskra shaman",33],["moor hound",33],["skeletal giant",33],["spectral warrior",34 ],["hisskra chieftain",34 ],["moor witch",34],["lava troll",34],["colossus vulture",34 ],["troll zombie",34 ],["tundra giant",34],["cold guardian",34],["skeletal soldier",34 ],["spectral shade",35],["shimmering fungus",35 ],["spectral woodsman",35 ],["barghest",35],["troll wraith",35],["water wyrd",35],["bog troll",35],["moor eagle",35],["snow crone",36],["dust beetle",36],["spectral lord",36],["fire giant",36],["undertaker bat",36],["arctic titan",36],["krolvin slaver",36],["shadow mare",37],["skeletal warhorse",37 ],["Sheruvian initiate",37 ],["lesser moor wight",37 ],["tusked ursian",37],["huge mein golem",37],["magru",37],["grizzly bear",38],["vesperti",38],["wood sprite",38],["shadow steed",38],["krolvin corsair",38],["mud wasp",38],["frost giant",38],["greater moor wight",39 ],["vourkha",39],["greater bog troll",39 ],["storm giant",39],["stone gargoyle",39],["myklian",40],["spectral miner",40],["kiramon worker",40],["lesser ice giant",41 ],["roa'ter",41],["Sheruvian monk",41],["skeletal lord",41],["bog wraith",41],["minor glacei",42],["dark vortece",42],["phantasma",42],["swamp hag",42],["frozen corpse",42],["baesrukha",42],["shan warrior",42],["shan ranger",42],["shan cleric",42],["shan wizard",42],["siren lizard",42],["wasp nest",43],["night mare",43],["dreadnought raptor",43 ],["bog wight",44],["forest trali shaman",44 ],["mastodonic leopard",44 ],["gaunt spectral servant",44 ],["firethorn shoot",44],["polar bear",44],["ice wraith",45],["lesser vruul",45],["greater ice giant",46 ],["kiramon defender",46 ],["cinder wasp",46],["forest trali",46],["rotting chimera",46],["lesser faeroth",46],["bog spectre",47],["major glacei",47],["horned vor'taz",48],["dybbuk",48],["necrotic snake",48],["sand devil",48],["red-scaled thrak",48 ],["warrior shade",48],["waern",49],["banshee",50],["flesh golem",50],["greater faeroth",50],["wooly mammoth",52],["tomb troll",52],["seeker",52],["snow madrinol",52],["lesser ice elemental",53 ],["sabre-tooth tiger",53 ],["ice golem",53],["stone sentinel",53],["animated slush",54],["skayl",54],["troll necromancer",54 ],["mage apprentice",54],["nightmare steed",55],["eidolon",55],["stone troll",55],["Citadel guardsman",56],["lava golem",56],["glacial morph",56],["stone giant",58],["Citadel arbalester",58],["massive pyrothag",58 ],["massive black boar",59 ],["forest viper",59 ],["fire elemental",60],["forest ogre",60 ],["Citadel herald",60],["stone mastiff",62],["bestial swordsman", 62],["Illoke mystic",62],["massive troll king",63 ],["ice elemental",63],["wind wraith",63],["soul golem",63],["Sheruvian harbinger",63 ],["fire sprite",64],["grifflet",64],["red tsark",66],["emaciated hierophant",66 ],["muscular supplicant",67 ],["Illoke shaman",67],["lesser griffin",69],["krag yeti",70],["hunch-backed dogmatist",70 ],["fire mage",71],["krag dweller",72],["storm griffin",73],["lesser minotaur",74],["moulis",75],["naisirc",75],["greater vruul",75],["minotaur warrior",76 ],["shrickhen",76],["csetairi",76],["raving lunatic",77],["farlook",77],["minotaur magus",78],["dhu goleras",78],["seraceris",78],["gnarled being",82],["caedera",82],["Vvrael witch",82],["lesser construct",83 ],["lich qyn'arj",84],["Vvrael warlock",84],["greater krynch",84],["gremlock",84],["festering taint",86],["aivren",86],["Illoke elder",86],["n'ecare",87],["greater earth elemental",88 ],["Illoke jarl",89],["Ithzir scout",89],["lost soul",91],["Ithzir initiate",91],["Ithzir janissary",92 ],["vaespilon",93],["Ithzir herald",93],["triton dissembler",94 ],["Ithzir adept",96],["siren",96],["triton executioner",96 ],["greater construct",96 ],["Ithzir seer",97],["triton combatant",98 ],["triton defender",98],["war griffin",100],["triton radical",100],["triton magus",102],["triton sentry",103],["greater water elemental",105],["water elemental",92],["rolton",1],["phantom",2],["wraith",15],["ghost",2],["skeleton",1],["kobold",1],["reiver",24],["thrak",8],["manticore",9],["goblin",2],["hobgoblin",3],["yeti",67],["spectre",14],["earth elemental",82],["fallen crusader",97],["murky soul siphon",106],["lich",110],["enormous rift crawler",103],["darkly inked fetish master", 104],["glistening cerebralite",100],["Vvrael destroyer",108],["zombie",23]]



settings['skin_exclude'] ||= Array.new
settings['loot_exclude'] ||= ""
settings['sell_exclude'] ||= "gold ring|(?:gold|aquamarine) wand|(?:white|black) crystal"

$sloot_has_disk    ||= false
$sloot_disk_full   ||= false
$sloot_searched    ||= false
$sloot_hooks       ||= Array.new
$sloot_locker_full ||= false

closed_sacks        = Array.new
prev_stance         = checkstance
skin_prepared       = false
skin_empty_hands    = false
sacks               = Hash.new
skinweaponcurrent   = nil
skinweapon          = nil
skinweaponblunt     = nil

change_stance = proc { |stance|
    loop {
        break if (checkstance == stance) or (stance == 'defensive' and checkstance 80)

        res = dothistimeout "stance #{stance}", 2, /You are now|Roundtime|Wait|wait|You move into/
        if res =~ /Roundtime: (\d+)|wait (\d+)/i
            sleep (($1 or $2).strip.to_f - 1)
        end
    }
}

go2 = proc { |room|
    next if Room.current.id.to_s == room.to_s

    wait_while{ running?('go2') }
    start_script('go2', [ room.to_s, '_disable_confirm_' ]);
    wait_while{ running?('go2') }
}

msg = proc { |str|
    echo str
}

setup = proc {
    gtk_globals = Hash.new
    gtk_locals = Hash.new

    window = window_action = nil

    Gtk.queue {
        ttips = Gtk::Tooltips.new.enable
        ttips_text = {
            'enable_close_sacks' => "Checking this will attempt to keep your sacks closed.",
            'overflowsack' => "Enter your overflow sack(s) to place loot into when your regular sack is full.\ne.g., \"pack,sack,cloak,hat\"",
            'loot_exclude' => "Regular expression used to exclude certain loot, e.g. \"feras|drake\".",
            'critter_exclude' => "Regular expression used to exclude certain critters, e.g. \"skayl|lava golem\".",
            'enable_search_all' => "Checking this enables searching all dead critters rather than one at a time.",
            'enable_disking' => "Checking this enables disking of boxes if you have a disk.",
            'enable_phasing' => "Checking this enables phasing of boxes if you meet the requirements.\nRequires: level 4 Sorcerer with 704 learned",
            'enable_gather' => "Checking this enables gathering of ammunition after looting.",
            'ammo_name' => "Enter the full name of your ammunition here.",
            'enable_safe_hiding' => "Checking this enables looting only if not hiding or there are no creatures present.",
            'safe_ignore' => "Enter the name of any creatures you want to ignore when safe hiding.\nThis field is a regular expression so use \"|\" to separate names.",
            'enable_stow_left' => "Checking this will store your left hand to loot if your hands are full.",
            'enable_self_drops' => "Checking this enables looting of items that were dropped from creatures you searched.",
            'enable_skinning' => "Checking this enables all skinning functionality.",
            'enable_stance_on_start' => "Check this enables stancing to defensive when starting sloot.",
            'enable_skin_alternate' => "Checking this enables an alternate weapon for skinning.",
            'enable_skin_offensive' => "Checking this enables skinning in offensive for a slight success increase (not proven).",
            'enable_skin_kneel' => "Checking this enables skinning while kneeling for a slight success increase.",
            'enable_skin_safe_mode' => "Checking this enables safe mode and will only stance/kneel if there are no alive critters present.",
            'enable_skin_604' => "Checking this enables the use of 604 (Skinning) if you meet the requirements.\nRequires: level 6 Ranger with 606 learned",
            'enable_skin_sigil' => "Checking this enables the use of Sigil of Resolve if you meet the requirements.\nRequires: GoS member with Sigil of Resolve learned",
            #'enable_skin_stats' => "Checking this enables skinning statistics. You can view them by using ;sloot stats.",
            'enable_skin_stance_first' => "Checking this enables stancing to previous stance before standing. This is disabled by default to prevent incuring additional roundtime from standing in defensive.",
            'skin_stand_verb' => "Enter the stand verb if you don't want to use the default STAND verb.\ne.g., \"rgambit tumble left\"",
            'enable_sell_chronomage' => "Checking this enables giving gold rings to the Chronomage during the sell process for credit towards a Chronomage ride.",
            'enable_sell_share_silvers' => "Checking this enables sharing all silvers with the group before depositing and gives them a few seconds to deposit their coins.",
            'sell_withdraw' => "Enter an amount to withdraw after the sell process completes. This is useful for towns with gate fees such as Icemule Trace.",
            'enable_sell_locksmith' => "Checking this enables the use the NPC locksmith to open your boxes.",
            'enable_locker_boxes' => "Checking this enables stashing of boxes until your locker is full",
            'enable_sell_stockpile' => "Checking this enables stockpiling of gems so that they can be turned in later for bounties. This requires you to have empty jars from the alchemist available in your locker.",
            #'enable_sell_force_bounty_gems' => "Checking this enables selling of gems for bounties even if you normally have gem selling disabled.",
            'locker' => "Enter the room number just OUTSIDE of where your locker is.",
            'locker_in' => "Enter the commands to get to your locker if it's not mapped'.",
            'locker_out' => "Enter the commands to exit your locker if it's not mapped.",
            'sell_exclude' => "Regular expression used to exclude loot from being sold, e.g., \"wand|crystal\""
        }

        gtk_globals['ammosack'] = Gtk::Entry.new.set_text(UserVars.ammosack)
        gtk_globals['boxsack'] = Gtk::Entry.new.set_text(UserVars.boxsack)
        gtk_globals['foragesack'] = Gtk::Entry.new.set_text(UserVars.foragesack)
        gtk_globals['gemsack'] = Gtk::Entry.new.set_text(UserVars.gemsack)
        gtk_globals['herbsack'] = Gtk::Entry.new.set_text(UserVars.herbsack)
        gtk_globals['jewelrysack'] = Gtk::Entry.new.set_text(UserVars.jewelrysack)
        gtk_globals['lockpicksack'] = Gtk::Entry.new.set_text(UserVars.lockpicksack)
        gtk_globals['magicsack'] = Gtk::Entry.new.set_text(UserVars.magicsack)
        gtk_globals['reagentsack'] = Gtk::Entry.new.set_text(UserVars.reagentsack)
        gtk_globals['scrollsack'] = Gtk::Entry.new.set_text(UserVars.scrollsack)
        gtk_globals['skinsack'] = Gtk::Entry.new.set_text(UserVars.skinsack)
        gtk_globals['uncommonsack'] = Gtk::Entry.new.set_text(UserVars.uncommonsack)
        gtk_globals['valuablesack'] = Gtk::Entry.new.set_text(UserVars.valuablesack)
        gtk_globals['clothingsack'] = Gtk::Entry.new.set_text(UserVars.clothingsack)
        gtk_globals['wandsack'] = Gtk::Entry.new.set_text(UserVars.wandsack)
        gtk_globals['skinweapon'] = Gtk::Entry.new.set_text(UserVars.skinweapon)
        gtk_globals['skinweaponblunt'] = Gtk::Entry.new.set_text(UserVars.skinweaponblunt)
        gtk_globals['skinweaponsack'] = Gtk::Entry.new.set_text(UserVars.skinweaponsack)
        gtk_locals['locker'] = Gtk::Entry.new.set_text(settings['locker'])
        gtk_locals['locker_in'] = Gtk::Entry.new.set_text(settings['locker_in'])
        gtk_locals['locker_out'] = Gtk::Entry.new.set_text(settings['locker_out'])

        gtk_locals['enable_close_sacks'] = Gtk::CheckButton.new('(?) Keep sacks shut').set_active(settings['enable_close_sacks'])
        gtk_locals['overflowsack'] = Gtk::Entry.new.set_text(settings['overflowsack'])
        gtk_locals['loot_exclude'] = Gtk::Entry.new.set_text(settings['loot_exclude'])
        gtk_locals['critter_exclude'] = Gtk::Entry.new.set_text(settings['critter_exclude'])
        gtk_locals['enable_search_all'] = Gtk::CheckButton.new('(?) Search all dead').set_active(settings['enable_search_all'])
        gtk_locals['enable_loot_box'] = Gtk::CheckButton.new('Boxes').set_active(settings['enable_loot_box'])
        gtk_locals['enable_loot_gem'] = Gtk::CheckButton.new('Gems').set_active(settings['enable_loot_gem'])
        gtk_locals['enable_loot_herb'] = Gtk::CheckButton.new('Herbs').set_active(settings['enable_loot_herb'])
        gtk_locals['enable_loot_jewelry'] = Gtk::CheckButton.new('Jewelry').set_active(settings['enable_loot_jewelry'])
        gtk_locals['enable_loot_lockpick'] = Gtk::CheckButton.new('Lockpicks').set_active(settings['enable_loot_lockpick'])
        gtk_locals['enable_loot_magic'] = Gtk::CheckButton.new('Magical').set_active(settings['enable_loot_magic'])
        gtk_locals['enable_loot_reagent'] = Gtk::CheckButton.new('Reagents').set_active(settings['enable_loot_reagent'])
        gtk_locals['enable_loot_scroll'] = Gtk::CheckButton.new('Scrolls').set_active(settings['enable_loot_scroll'])
        gtk_locals['enable_loot_skin'] = Gtk::CheckButton.new('Skins').set_active(settings['enable_loot_skin'])
        gtk_locals['enable_loot_uncommon'] = Gtk::CheckButton.new('Uncommon').set_active(settings['enable_loot_uncommon'])
        gtk_locals['enable_loot_valuable'] = Gtk::CheckButton.new('Valuables').set_active(settings['enable_loot_valuable'])
        gtk_locals['enable_loot_clothing'] = Gtk::CheckButton.new('Clothings').set_active(settings['enable_loot_clothing'])
        gtk_locals['enable_loot_wand'] = Gtk::CheckButton.new('Wands').set_active(settings['enable_loot_wand'])
        gtk_locals['enable_disking'] = Gtk::CheckButton.new('(?) Disking').set_active(settings['enable_disking'])
        gtk_locals['enable_phasing'] = Gtk::CheckButton.new('(?) Phasing').set_active(settings['enable_phasing'])
        gtk_locals['enable_gather'] = Gtk::CheckButton.new('(?) Gather ammo').set_active(settings['enable_gather'])
        gtk_locals['ammo_name'] = Gtk::Entry.new.set_text(settings['ammo_name'])
        gtk_locals['enable_safe_hiding'] = Gtk::CheckButton.new('(?) Safe hiding').set_active(settings['enable_safe_hiding'])
        gtk_locals['safe_ignore'] = Gtk::Entry.new.set_text(settings['safe_ignore'])
        gtk_locals['enable_stow_left'] = Gtk::CheckButton.new('(?) Stow left hand').set_active(settings['enable_stow_left'])
        gtk_locals['enable_stance_on_start'] = Gtk::CheckButton.new('(?) Stance on start').set_active(settings['enable_stance_on_start'])
        gtk_locals['enable_self_drops'] = Gtk::CheckButton.new('(?) Self loot only').set_active(settings['enable_self_drops'])
        gtk_locals['enable_skinning'] = Gtk::CheckButton.new('(?) Enable skinning').set_active(settings['enable_skinning'])
        gtk_locals['enable_skin_alternate'] = Gtk::CheckButton.new('(?) Enable alternate').set_active(settings['enable_skin_alternate'])
        gtk_locals['enable_skin_offensive'] = Gtk::CheckButton.new('(?) Skin in offensive').set_active(settings['enable_skin_offensive'])
        gtk_locals['enable_skin_kneel'] = Gtk::CheckButton.new('(?) Kneel to skin').set_active(settings['enable_skin_kneel'])
        gtk_locals['enable_skin_safe_mode'] = Gtk::CheckButton.new('(?) Safe mode').set_active(settings['enable_skin_safe_mode'])
        gtk_locals['enable_skin_stance_first'] = Gtk::CheckButton.new('(?) Stance first').set_active(settings['enable_skin_stance_first'])
        gtk_locals['enable_skin_604'] = Gtk::CheckButton.new('(?) Use 604').set_active(settings['enable_skin_604'])
        gtk_locals['enable_skin_sigil'] = Gtk::CheckButton.new('(?) Use Sigil of Resolve').set_active(settings['enable_skin_sigil'])
        #gtk_locals['enable_skin_stats'] = Gtk::CheckButton.new('(?) Track statistics').set_active(settings['enable_skin_stats']).set_sensitive(false)
        gtk_locals['skin_stand_verb'] = Gtk::Entry.new.set_text(settings['skin_stand_verb'])
        gtk_locals['enable_sell_type_gem'] = Gtk::CheckButton.new('Gems').set_active(settings['enable_sell_type_gem'])
        gtk_locals['enable_sell_type_valuable'] = Gtk::CheckButton.new('Valuables').set_active(settings['enable_sell_type_valuable'])
        gtk_locals['enable_sell_type_clothing'] = Gtk::CheckButton.new('Clothings').set_active(settings['enable_sell_type_clothing'])
        gtk_locals['enable_sell_type_jewelry'] = Gtk::CheckButton.new('Jewelry').set_active(settings['enable_sell_type_jewelry'])
        gtk_locals['enable_sell_type_lockpick'] = Gtk::CheckButton.new('Lockpicks').set_active(settings['enable_sell_type_lockpick'])
        gtk_locals['enable_sell_type_magic'] = Gtk::CheckButton.new('Magical').set_active(settings['enable_sell_type_magic'])
        gtk_locals['enable_sell_type_reagent'] = Gtk::CheckButton.new('Reagents').set_active(settings['enable_sell_type_reagent'])
        gtk_locals['enable_sell_type_scroll'] = Gtk::CheckButton.new('Scrolls').set_active(settings['enable_sell_type_scroll'])
        gtk_locals['enable_sell_type_skin'] = Gtk::CheckButton.new('Skins').set_active(settings['enable_sell_type_skin'])
        gtk_locals['enable_sell_type_scarab'] = Gtk::CheckButton.new('Scarabs to gemshop').set_active(settings['enable_sell_type_scarab'])
        gtk_locals['enable_sell_type_empty_box'] = Gtk::CheckButton.new('Boxes as empties').set_active(settings['enable_sell_type_empty_box'])
        gtk_locals['enable_sell_type_wand'] = Gtk::CheckButton.new('Wands').set_active(settings['enable_sell_type_wand'])
        gtk_locals['enable_sell_chronomage'] = Gtk::CheckButton.new('(?) Rings -> Chrono').set_active(settings['enable_sell_chronomage'])
        gtk_locals['enable_sell_share_silvers'] = Gtk::CheckButton.new('(?) Share silvers').set_active(settings['enable_sell_share_silvers'])
        gtk_locals['sell_withdraw'] = Gtk::Entry.new.set_text(settings['sell_withdraw'])
        gtk_locals['enable_sell_locksmith'] = Gtk::CheckButton.new('(?) Enable locksmith').set_active(settings['enable_sell_locksmith'])
        gtk_locals['enable_locker_boxes'] = Gtk::CheckButton.new('(?) Enable lockering').set_active(settings['enable_locker_boxes'])
        gtk_locals['enable_sell_stockpile'] = Gtk::CheckButton.new('(?) Stockpile gems').set_active(settings['enable_sell_stockpile'])
        #gtk_locals['enable_sell_force_bounty_gems'] = Gtk::CheckButton.new('(?) Force sell gems').set_active(settings['enable_sell_force_bounty_gems']).set_sensitive(false)
        gtk_locals['sell_exclude'] = Gtk::Entry.new.set_text(settings['sell_exclude'])

        # Signals
        gtk_locals['ammo_name'].sensitive = gtk_locals['enable_gather'].active?
        gtk_locals['enable_gather'].signal_connect('toggled') { gtk_locals['ammo_name'].sensitive = gtk_locals['enable_gather'].active? }

        gtk_locals['safe_ignore'].sensitive = gtk_locals['enable_safe_hiding'].active?
        gtk_locals['enable_safe_hiding'].signal_connect('toggled') { gtk_locals['safe_ignore'].sensitive = gtk_locals['enable_safe_hiding'].active? }

        # Add tooltips
        ttips_text.each_pair { |widget,tip|
            if widget = gtk_globals[widget] or gtk_locals[widget]
                ttips.set_tip(widget,tip,'')
            end
        }

        # Primary Window
        window = Gtk::Window.new
        window.title = "SLoot configuration for #{Char.name}"
        window.border_width = 3
        window.resizable = false
        window.resize(450, 300)

        # Notebooks for tabs at the top
        nb = Gtk::Notebook.new.set_show_border(true).set_tab_border(3)

        #
        # Notebook Page 1 - Sacks
        #
        vb_pg1 = Gtk::VBox.new(false,1).set_border_width(3)

        #
        # Page 1, Frame 1 - Sacks
        #
        vb_pg1_1 = Gtk::VBox.new(false,1).set_border_width(3)
        fr_pg1_1 = Gtk::Frame.new.set_border_width(5).set_label_widget(Gtk::Label.new.set_markup('<big><b>Sacks</b></big>'))
        fr_pg1_1.add(vb_pg1_1)
        vb_pg1.pack_start(fr_pg1_1,false)

        lbl = Gtk::Label.new.set_markup("SLoot features sorting of loot by allowing you to specify " +
            "a sack for each type of loot. Use the fields below to set the sack(s) for " +
            "each loot type.")
        lbl.set_wrap(true).set_width_request(500).set_padding(0,10)
        vb_pg1_1.pack_start(lbl,false)

        hb = Gtk::HBox.new(false,1)
        hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Ammunition:')).set_width_request(100))
        hb.pack_start(gtk_globals['ammosack'],false)
        hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Boxes:')).set_width_request(100))
        hb.pack_start(gtk_globals['boxsack'],false)
        vb_pg1_1.pack_start(hb,false)

        hb = Gtk::HBox.new(false,1)
        hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Gems:')).set_width_request(100))
        hb.pack_start(gtk_globals['gemsack'],false)
        hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Herbs:')).set_width_request(100))
        hb.pack_start(gtk_globals['herbsack'],false)
        vb_pg1_1.pack_start(hb,false)

        hb = Gtk::HBox.new(false,1)
        hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Jewelry:')).set_width_request(100))
        hb.pack_start(gtk_globals['jewelrysack'],false)
        hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Lockpicks:')).set_width_request(100))
        hb.pack_start(gtk_globals['lockpicksack'],false)
        vb_pg1_1.pack_start(hb,false)

        hb = Gtk::HBox.new(false,1)
        hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Magical:')).set_width_request(100))
        hb.pack_start(gtk_globals['magicsack'],false)
        hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Reagents:')).set_width_request(100))
        hb.pack_start(gtk_globals['reagentsack'],false)
        vb_pg1_1.pack_start(hb,false)

        hb = Gtk::HBox.new(false,1)
        hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Scrolls:')).set_width_request(100))
        hb.pack_start(gtk_globals['scrollsack'],false)
        hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Skins:')).set_width_request(100))
        hb.pack_start(gtk_globals['skinsack'],false)
        vb_pg1_1.pack_start(hb,false)

        hb = Gtk::HBox.new(false,1)
        hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Uncommon:')).set_width_request(100))
        hb.pack_start(gtk_globals['uncommonsack'],false)
        hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Wands:')).set_width_request(100))
        hb.pack_start(gtk_globals['wandsack'],false)
        vb_pg1_1.pack_start(hb,false)

        hb = Gtk::HBox.new(false,1)
        hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Clothings:')).set_width_request(100))
        hb.pack_start(gtk_globals['clothingsack'],false)
        hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Valuables:')).set_width_request(100))
        hb.pack_start(gtk_globals['valuablesack'],false)

        vb_pg1_1.pack_start(hb,false)

        hb = Gtk::HBox.new(false,1)
        hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('(?) Overflow:')).set_width_request(100),false)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['overflowsack'].set_width_request(419)))
        vb_pg1_1.pack_start(hb,false)

        #
        # Page 1, Frame 2 - Locker
        #
        vb_pg1_2 = Gtk::VBox.new(false,1).set_border_width(3)
        fr_pg1_2 = Gtk::Frame.new.set_border_width(5).set_label_widget(Gtk::Label.new.set_markup('<big><b>Locker</b></big>'))
        fr_pg1_2.add(vb_pg1_2)
        vb_pg1.pack_start(fr_pg1_2,false)

        hb = Gtk::HBox.new(false,1)
        hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('(?) Locker:')),false)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['locker']),false)
        hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('(?) Locker in:')),false)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['locker_in']),false)
        hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('(?) Locker out:')),false)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['locker_out']),false)
        vb_pg1_2.pack_start(hb,false)

        #
        # Page 1, Frame 3 - Advanced Options
        #
        vb_pg1_3 = Gtk::VBox.new(false,1).set_border_width(3)
        fr_pg1_3 = Gtk::Frame.new.set_border_width(5).set_label_widget(Gtk::Label.new.set_markup('<big><b>Advanced Options</b></big>'))
        fr_pg1_3.add(vb_pg1_3)
        vb_pg1.pack_start(fr_pg1_3,false)

        hb = Gtk::HBox.new(false,1)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_close_sacks'].set_width_request(150)),false)
        vb_pg1_3.pack_start(hb,false)

        lbl = Gtk::Label.new.set_markup("<span color=\"blue\" weight=\"bold\">Tip: (?) " +
            "in front of any option means you can hover over it for additional information.</span>")
        lbl.set_wrap(true).set_width_request(500).set_padding(0,10)
        vb_pg1_1.pack_start(lbl,false)

        nb.append_page(vb_pg1,Gtk::Label.new('Sacks'))

        #
        # Notebook Page 2 - Looting
        #
        vb_pg2 = Gtk::VBox.new(false,1).set_border_width(3)

        #
        # Page 2, Frame 1 - Looting
        #
        vb_pg2_1 = Gtk::VBox.new(false,1).set_border_width(3)
        fr_pg2_1 = Gtk::Frame.new.set_border_width(5).set_label_widget(Gtk::Label.new.set_markup('<big><b>Looting</b></big>'))
        fr_pg2_1.add(vb_pg2_1)
        vb_pg2.pack_start(fr_pg2_1,false)

        lbl = Gtk::Label.new.set_markup("Use the options below to specify how " +
        "SLoot behaves when looting. Each checkbox represents a loot category which SLoot will only " +
        "pickup if checked. You can also enabled advanced features such as autolooting, disking/phasing " +
        "of boxes, and looting drops from critters you search.")
        lbl.set_wrap(true).set_width_request(500).set_padding(0,10)
        vb_pg2_1.pack_start(lbl,false)

        hb = Gtk::HBox.new(false,1)
        hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('(?) Exclude critters:')).set_width_request(100),false)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['critter_exclude'].set_width_request(419)))
        vb_pg2_1.pack_start(hb,false)

        hb = Gtk::HBox.new(false,1)
        hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('(?) Exclude loot:')).set_width_request(100),false)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['loot_exclude'].set_width_request(419)))
        vb_pg2_1.pack_start(hb,false)

        hb = Gtk::HBox.new(false,1)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_search_all'].set_width_request(129)),false)
        vb_pg2_1.pack_start(hb,false)

        hb = Gtk::HBox.new(false,1)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_loot_box'].set_width_request(129)),false)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_loot_gem'].set_width_request(129)),false)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_loot_herb'].set_width_request(129)),false)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_loot_jewelry'].set_width_request(129)),false)
        vb_pg2_1.pack_start(hb,false)

        hb = Gtk::HBox.new(false,1)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_loot_lockpick'].set_width_request(129)),false)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_loot_magic'].set_width_request(129)),false)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_loot_reagent'].set_width_request(129)),false)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_loot_scroll'].set_width_request(129)),false)
        vb_pg2_1.pack_start(hb,false)

        hb = Gtk::HBox.new(false,1)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_loot_skin'].set_width_request(129)),false)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_loot_wand'].set_width_request(129)),false)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_loot_uncommon'].set_width_request(129)),false)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_loot_valuable'].set_width_request(129)),false)
        vb_pg2_1.pack_start(hb,false)

        hb = Gtk::HBox.new(false,1)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_loot_clothing'].set_width_request(129)),false)

        vb_pg2_1.pack_start(hb,false)

        #
        # Page 2, Frame 1 - Looting
        #
        vb_pg2_2 = Gtk::VBox.new(false,1).set_border_width(3)
        fr_pg2_1 = Gtk::Frame.new.set_border_width(5).set_label_widget(Gtk::Label.new.set_markup('<big><b>Advanced Options</b></big>'))
        fr_pg2_1.add(vb_pg2_2)
        vb_pg2.pack_start(fr_pg2_1,false)

        hb = Gtk::HBox.new(false,1)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_disking'].set_width_request(129)),false)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_stow_left'].set_width_request(129)),false)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_self_drops'].set_width_request(129)),false)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_stance_on_start'].set_width_request(129)),false)

        if Char.prof == 'Sorcerer' and Char.level > 3 and Spell[704].known?
            hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_phasing'].set_width_request(129)),false)
        end

        vb_pg2_2.pack_start(hb,false)

        hb = Gtk::HBox.new(false,1)
        hb.pack_start(Gtk::Alignment.new(1,0,0,0).add(gtk_locals['enable_safe_hiding'].set_width_request(129)),false)
        hb.pack_start(gtk_locals['safe_ignore'],false)
        vb_pg2_2.pack_start(hb,false)

        hb = Gtk::HBox.new(false,1)
        hb.pack_start(Gtk::Alignment.new(1,0,0,0).add(gtk_locals['enable_gather'].set_width_request(129)),false)
        hb.pack_start(gtk_locals['ammo_name'],false)
        vb_pg2_2.pack_start(hb,false)

        nb.append_page(vb_pg2, Gtk::Label.new('Looting'))

        #
        # Notebook Page 3 - Skinning
        #
        vb_pg3 = Gtk::VBox.new(false,1).set_border_width(3)

        #
        # Page 3, Frame 1 - Skinning
        #
        vb_pg3_1 = Gtk::VBox.new(false,1).set_border_width(3)
        fr_pg3_1 = Gtk::Frame.new.set_border_width(5).set_label_widget(Gtk::Label.new.set_markup('<big><b>Skinning</b></big>'))
        fr_pg3_1.add(vb_pg3_1)
        vb_pg3.pack_start(fr_pg3_1,false)

        lbl = Gtk::Label.new.set_markup("The options below give you absolute control over skinning critters. " +
            "You can use your current weapon, an alternate weapon, left or right hand, and advanced enhancements " +
            "such as kneeling, stancing to offensive, Skinning (604) and Sigil of Resolve.")
        lbl.set_wrap(true).set_width_request(500).set_padding(0,10)
        vb_pg3_1.pack_start(lbl,false)

        hb = Gtk::HBox.new(false,1)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_skinning'].set_width_request(129)),false)
        vb_pg3_1.pack_start(hb,false)

        #
        # Page 3, Frame 2 - Alternate Weapon
        #
        vb_pg3_2 = Gtk::VBox.new(false,1).set_border_width(3)
        fr_pg3_2 = Gtk::Frame.new.set_border_width(5).set_label_widget(Gtk::Label.new.set_markup('<big><b>Alternate Skinning Weapon</b></big>'))
        fr_pg3_2.add(vb_pg3_2)
        vb_pg3.pack_start(fr_pg3_2,false)

        hb = Gtk::HBox.new(false,1)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_skin_alternate'].set_width_request(129)),false)
        vb_pg3_2.pack_start(hb,false)

        hb = Gtk::HBox.new(false,1)
        hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Regular:')),false)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_globals['skinweapon']),false)
        hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Sack:')),false)
        hb.pack_start(gtk_globals['skinweaponsack'],false)
        vb_pg3_2.pack_start(hb,false)

        hb = Gtk::HBox.new(false,1)
        hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Blunt:')),false)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_globals['skinweaponblunt']),false)
        vb_pg3_2.pack_start(hb,false)

        #
        # Page 3, Frame 3 - Enhancements
        #
        vb_pg3_3 = Gtk::VBox.new(false,1).set_border_width(3)
        fr_pg3_3 = Gtk::Frame.new.set_border_width(5).set_label_widget(Gtk::Label.new.set_markup('<big><b>Enhancements</b></big>'))
        fr_pg3_3.add(vb_pg3_3)
        vb_pg3.pack_start(fr_pg3_3,false)

        hb = Gtk::HBox.new(false,1)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_skin_offensive'].set_width_request(129)),false)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_skin_kneel'].set_width_request(129)),false)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_skin_safe_mode'].set_width_request(129)),false)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_skin_stance_first'].set_width_request(129)),false)
        vb_pg3_3.pack_start(hb,false)

        if (Char.prof == 'Ranger' and Char.level > 3 and Spell[604].known?) or (Spell[9704].known?)
            hb = Gtk::HBox.new(false,1)

            if Char.prof == 'Ranger' and Char.level > 3 and Spell[604].known?
                hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_skin_604'].set_width_request(129)),false)
            end

            if Spell[9704].known?
                hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_skin_sigil'].set_width_request(129)),false)
            end

            vb_pg3_3.pack_start(hb,false)
        end

        #
        # Page 3, Frame 4 - Advanced Options
        #
        vb_pg3_4 = Gtk::VBox.new(false,1).set_border_width(3)
        fr_pg3_4 = Gtk::Frame.new.set_border_width(5).set_label_widget(Gtk::Label.new.set_markup('<big><b>Advanced Options</b></big>'))
        fr_pg3_4.add(vb_pg3_4)

        hb = Gtk::HBox.new(false,1)
        #hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_skin_stats'].set_width_request(129)),false)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(Gtk::Label.new('(?) Stand verb:')).set_width_request(100),false)
        hb.pack_start(gtk_locals['skin_stand_verb'],false)
        vb_pg3_4.pack_start(hb,false)

        vb_pg3.pack_start(fr_pg3_4,false)

        nb.append_page(vb_pg3, Gtk::Label.new('Skinning'))

        #
        # Notebook Page 4 - Skinning
        #
        vb_pg4 = Gtk::VBox.new(false,1).set_border_width(3)

        #
        # Page 4, Frame 1 - Selling
        #
        vb_pg4_1 = Gtk::VBox.new(false,1).set_border_width(3)
        fr_pg4_1 = Gtk::Frame.new.set_border_width(5).set_label_widget(Gtk::Label.new.set_markup('<big><b>Selling</b></big>'))
        fr_pg4_1.add(vb_pg4_1)
        vb_pg4.pack_start(fr_pg4_1,false)

        lbl = Gtk::Label.new.set_markup("SLoot comes with a built in sell option that will sell all " +
        "loot and even open boxes at the town locksmith. Use the checkboxes to set what type of loot " +
        "you want to sell and the advanced options to customize exactly how selling operates.")
        lbl.set_wrap(true).set_width_request(500).set_padding(0,10)
        vb_pg4_1.pack_start(lbl,false)

        hb = Gtk::HBox.new(false,1)
        hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('(?) Exclude loot:')).set_width_request(100),false)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['sell_exclude'].set_width_request(419)))
        vb_pg4_1.pack_start(hb,false)

        hb = Gtk::HBox.new(false,1)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_sell_type_gem'].set_width_request(129)),false)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_sell_type_jewelry'].set_width_request(129)),false)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_sell_type_lockpick'].set_width_request(129)),false)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_sell_type_magic'].set_width_request(129)),false)
        vb_pg4_1.pack_start(hb,false)

        hb = Gtk::HBox.new(false,1)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_sell_type_reagent'].set_width_request(129)),false)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_sell_type_scroll'].set_width_request(129)),false)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_sell_type_skin'].set_width_request(129)),false)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_sell_type_wand'].set_width_request(129)),false)
        vb_pg4_1.pack_start(hb,false)

        hb = Gtk::HBox.new(false,1)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_sell_type_valuable'].set_width_request(129)),false)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_sell_type_clothing'].set_width_request(129)),false)
        vb_pg4_1.pack_start(hb,false)

        hb = Gtk::HBox.new(false,1)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_sell_type_empty_box'].set_width_request(129)),false)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_sell_type_scarab'].set_width_request(129)),false)
        vb_pg4_1.pack_start(hb,false)

        #
        # Page 4, Frame 2 - Cleanup
        #
        vb_pg4_2 = Gtk::VBox.new(false,1).set_border_width(3)
        fr_pg4_2 = Gtk::Frame.new.set_border_width(5).set_label_widget(Gtk::Label.new.set_markup('<big><b>Cleanup</b></big>'))
        fr_pg4_2.add(vb_pg4_2)
        vb_pg4.pack_start(fr_pg4_2,false)

        hb = Gtk::HBox.new(false,1)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_sell_chronomage'].set_width_request(129)),false)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_sell_share_silvers'].set_width_request(129)),false)
        hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('(?) Withdraw:')).set_width_request(100),false)
        hb.pack_start(gtk_locals['sell_withdraw'],false)
        vb_pg4_2.pack_start(hb,false)

        #
        # Page 4, Frame 3 - Boxes
        #
        vb_pg4_3 = Gtk::VBox.new(false,1).set_border_width(3)
        fr_pg4_3 = Gtk::Frame.new.set_border_width(5).set_label_widget(Gtk::Label.new.set_markup('<big><b>Boxes</b></big>'))
        fr_pg4_3.add(vb_pg4_3)
        vb_pg4.pack_start(fr_pg4_3,false)

        hb = Gtk::HBox.new(false,1)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_locker_boxes'].set_width_request(129)),false)
        vb_pg4_3.pack_start(hb,false)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_sell_locksmith'].set_width_request(129)),false)
        vb_pg4_3.pack_start(hb,false)

        #
        # Page 4, Frame 4 - Bounties
        #
        vb_pg4_4 = Gtk::VBox.new(false,1).set_border_width(3)
        fr_pg4_4 = Gtk::Frame.new.set_border_width(5).set_label_widget(Gtk::Label.new.set_markup('<big><b>Bounties</b></big>'))
        fr_pg4_4.add(vb_pg4_4)
        vb_pg4.pack_start(fr_pg4_4,false)

        hb = Gtk::HBox.new(false,1)
        hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_sell_stockpile'].set_width_request(129)),false)
        #hb.pack_start(Gtk::Alignment.new(0,0,0,1).add(gtk_locals['enable_sell_force_bounty_gems'].set_width_request(129)),false)
        vb_pg4_4.pack_start(hb,false)

        nb.append_page(vb_pg4, Gtk::Label.new('Selling'))

        # Save/Close buttons
        hb_saveclose = Gtk::HBox.new
        save = Gtk::Button.new('_Save & Close')
        close = Gtk::Button.new('E_xit')

        save.signal_connect('clicked') { window_action = :save }
        close.signal_connect('clicked') { window_action = :done }

        hb_saveclose.pack_start(save,false)
        hb_saveclose.pack_start(close,false)

        # Primary VerticalBox to split up Notebook and Save/Close buttons
        vb_main = Gtk::VBox.new(false,5)
        vb_main.border_width = 3

        vb_main.pack_start(nb,false)
        vb_main.pack_start(Gtk::Alignment.new(1,0,0,0).add(hb_saveclose),false)

        window.signal_connect('delete_event') { window_action = :exit }

        window.add(vb_main)
        window.show_all
        window.keep_above = true # On windows keep_above is required AFTER show_all
    }

    before_dying { Gtk.queue { window.destroy } }
    wait_while { window_action.nil? }

    clean_entry = proc { |entry|
        entry.text = entry.text.strip
        if entry.text.empty?
            entry.text = nil
        end

        entry.text
    }

    if window_action == :save
        gtk_globals.each_pair { |option,widget|
            if widget.class == Gtk::CheckButton
                UserVars.change(option,widget.active?,:char)
            elsif widget.class == Gtk::Entry
                UserVars.change(option,clean_entry.call(widget),:char)
            else
                echo "error: unknown global widget #{option} [#{widget.class}]"
            end
        }

        gtk_locals.each_pair { |option,widget|
            if widget.class == Gtk::CheckButton
                settings[option] = widget.active?
            elsif widget.class == Gtk::Entry
                settings[option] = clean_entry.call(widget)
            else
                echo "error: unknown local widget #{option} [#{widget.class}]"
            end
        }

        echo 'settings saved'
        $lootable=nil
    else
        echo 'closed without saving'
    end
}

# Installs hooks that sloot uses to function. Will only install a hook
# once in order to increase performance.
install_hooks = proc { |type|
    if settings['enable_disking']
        if !$sloot_hooks.include?(:disk)
            $sloot_hooks.push(:disk)

            hook = proc { |server_string|
                if server_string =~ /from in the <a exist="(?:\d+)" noun="disk">.*#{Char.name} disk<\/a>|You give your disk a flip/
                    $sloot_has_disk = true
                    $sloot_disk_full = false
                elsif server_string =~ /#{Char.name} disk in a dismissing gesture./
                    $sloot_has_disk = false
                    $sloot_disk_full = false
                elsif server_string =~ /^Your <a exist=".*" noun="disk">disk<\/a> arrives|^A small circular container suddenly appears/
                    $sloot_has_disk = true
                    $sloot_disk_full = false
                elsif server_string =~ /^Your .* won't fit in the .*disk.*$/
                    $sloot_has_disk = true
                    $sloot_disk_full = true
                end

                server_string
            }

            DownstreamHook.add('SLootDisk', hook)
        end
    elsif $sloot_hooks.include?(:disk)
        DownstreamHook.remove('SLootDisk')
    end
    if !$sloot_hooks.include?(:sloot_gameobj_watcher)
        $sloot_hooks.push(:sloot_gameobj_watcher)
        sloot_gameobj_watcher_hook = proc { |server_string|
            if server_string =~ /You (?:reach out to )?search/
                $sloot_searched = true
            #elsif  $sloot_searched && server_string =~ /exist="(?<exist>.*?)".*which looks like the heirloom that you are searching for/
                #unless GameObj.loot.find { |obj| obj.id == exist }
                #    GameObj.new_loot(exist, noun, name)
                #$sloot_searched = false
            elsif $sloot_searched && server_string =~ /had nothing else of value\.|had nothing of interest\.|^A.+ body shimmers slightly, then fades from view like a dissipating phantom\.$|prompt/
                $sloot_searched = false
            elsif $sloot_searched && server_string !~ /prompt/
                for link in server_string.scan(/<a.*?>.*?<\/a>/)
                    if link =~ /<a exist="(.*?)" noun="(.*?)">(.*?)<\/a>/
                        exist, noun, name = $1, $2, $3
                        next if name =~ /^(?:he|she|it|her|his|him|its|itself)$|'s$/i
                        GameObj.new_loot(exist, noun, name) unless GameObj.loot.find { |obj| obj.id == exist } or GameObj.inv.find{|obj| obj.id == exist}
                    end
                end
            end
            server_string
        }
        DownstreamHook.add('SLootGameObjWatcher', sloot_gameobj_watcher_hook)
    end
}

# Get dem silvers
checksilvers = proc {
    silvers = nil
    action = proc { |server_string|
        if server_string !~ /^\s*Mana\:\s+\-?[0-9]+\s+Silver\:\s+([0-9]+)/
            nil
        elsif server_string =~ /^\s*Mana\:\s+\-?[0-9]+\s+Silver\:\s+([0-9]+)/
            silvers = $1.to_i
            DownstreamHook.remove("slib_check_silvers")
            nil
        else
            server_string
        end
    }
    DownstreamHook.add("slib_check_silvers", action)
    $_SERVER_.puts "#{$cmd_prefix}info\n"
    wait_until { silvers }
    silvers
}

# Deposits coins in the bank
deposit_coins = proc {
    silvers = checksilvers.call.to_i
    withdraw = settings['sell_withdraw'].to_i

    if (silvers == 0 and withdraw == 0) or silvers == withdraw
        next
    end

    go2.call('bank')

    if settings['enable_sell_share_silvers'] and silvers > 1
        dothistimeout "share all", 5, /In order to share|share/
    end
    res = dothistimeout "deposit all", 5, /The teller carefully records the transaction|^You have no coins to deposit\.$/

    if (withdraw > 0)
        dothistimeout "withdraw #{withdraw} silvers", 5, /^The teller carefully records the transaction, and then hands you \d+ silvers\.$|Very well/
    end
}

# Opens up a sack and keeps a record of it
open_sack = proc { |sack|
    unless sack.class == GameObj or sack = GameObj[sack]
        echo "fixme: open_sack failed to find #{sack}"
        exit
    end

    res = dothistimeout "open ##{sack.id}", 5, /^You open .*\.$/
    unless res
        echo "fixme: unknown open_sack result: #{res}"
        exit
    end

    closed_sacks.push(sack.id)
}

# Closes all opened sacks in closed_sacks
close_open_sacks = proc {
    next unless settings['enable_close_sacks']

    closed_sacks.each { |sack|
        res = dothistimeout "close ##{sack}", 5, /^You close .*\.$/
        unless res
            echo "fixme: unknown close_open_sacks result: #{res}"
            exit
        end
    }
}

# Puts an item somewhere
put_item = proc { |item, sack|
    if item.class != GameObj
        print.call("WARNING: item #{item} passed to put_item was not a GameObj")
    end

    if sack.class != GameObj
        print.call("WARNING: sack #{sack} passed to put_item was not a GameObj")
    end

    waitrt?

    next false unless GameObj.right_hand.id == item or GameObj.left_hand.id == item or checkleft =~ /#{item}/ or checkright =~ /#{item}/

    if sack.class == GameObj or sack = GameObj[sack]
        fput "put my #{item} in ##{sack.id}"
    else
        fput "put my #{item} in my #{sack}"
    end

    noun   = item.class == GameObj ? item.noun : item
    result = false
    30.times {
        waitrt?

        if GameObj.right_hand.id != item and GameObj.left_hand.id != item and (not checkleft or noun !~ /#{checkleft}/) and (not checkright or noun !~ /#{checkright}/)
            result = true
            break
        end

        line = get?
        if line =~ /^You can't put .* in .*\.  It's closed\!$/
            open_sack.call(sack)
            next put_item.call(item,sack)
        elsif line =~ /^Your .* won't fit in .*\.$|find there is no space for the/
            break
        end

        sleep 0.10
    }

    result
}

# Gets an item
get_item = proc { |item, sack|
    waitrt?

    next true if GameObj.right_hand.id == item or GameObj.left_hand.id == item or checkleft =~ /#{item}/ or checkright =~ /#{item}/

    id = item.class == GameObj ? "##{item.id}" : item

	#(X)
	#echo "     GET ITEM .... " + id.to_s + " - " + item.name
	
    if sack.nil?
        fput "get #{id}"
    elsif sack.class == GameObj or sack = GameObj[sack]
        fput "get #{id} from ##{sack.id}"
    else
        fput "get #{id} from my #{sack}"
    end

    noun   = item.class == GameObj ? item.noun : item
    result = false
    30.times {
        waitrt?

        if GameObj.right_hand.id == item or GameObj.left_hand.id == item or (checkleft and noun =~ /#{checkleft}/) or (checkright and noun =~ /#{checkright}/)
            result = true
            break
        end

        line = get?
        if line =~ /is out of your reach/
            sleep 4
            next get_item.call(item, sack)
        elsif line =~ /^You can't pick that up\.$|^Get what?$|crumbles and decays away.$|crumbles into a pile of dust!$/
            break
        end

        sleep 0.10
    }

    result
}

# Waits until your disk is present or a timeout occurs
check_for_disk = proc {
    disk = nil
    notified = false
    25.times {
        break if disk = GameObj[/^.*#{Char.name} (?:disk|coffin)$/]
        sleep 0.2
        unless notified
            msg.call("-- waiting on your disk to arrive")
            notified = true
        end
    }

    unless disk
        $sloot_has_disk = false
    end

    disk
}

# Withdraws coins from the bank, hooray!
withdraw_coins = proc { |amount|
    success = true
    room = Room.current.id

    coins = checksilvers.call
    if coins < amount
        go2.call('bank')

        dothistimeout "unhide", 5, /hiding|visible/ if invisible? or hiding?
        res = dothistimeout "withdraw #{amount-coins} silvers", 5, /^The teller carefully records the transaction, and then hands you \d+ silvers?\.$|I'm sorry, .*, you don't seem to have that much in the account\./
        case res
            when /I'm sorry/
                success = false
            when /^The teller carefully/
            else
                echo "unknown response for withdraw_coins: #{res}"
        end
    end

    go2.call(room)

    success
}

loot_list = CharSettings['lootlist'] 

# Grabs loot!
grab_loot = proc { |loot, from|

	lootFrom = from ||= nil 

    type = loot.type.split(',').first

	#(X)
	
	#echo "++++++++++++++++++++++++"
	#echo "Room #: " + Room.current.id.to_s
	#echo "Room Location: " + Room.current.location
	
	#echo "++++++++++++++++++++++++"
	#echo loot.to_s
	#echo lootFrom.to_s
	#echo lootFrom
	#echo "++++++++++++++++++++++++"
	
	if CharSettings['lootlist'].nil?
		CharSettings['lootlist']=Array.new
		CharSettings['lootlist'].push(h={:from=>lootFrom,:name=>loot.name,:type=>type,:count=>1})
		
		tmpFrom = lootFrom.to_s ||= "None"
		
		#echo "++++++++++++++++++++++++"
		#echo "From: " + tmpFrom + " Loot: " + loot.name + " Type: " + type + " Count: 1"
		#echo "++++++++++++++++++++++++"
		
		CharSettings.save
	else
		found=false
		CharSettings['lootlist'].each{|monster|
			if monster[:name]==loot.name then
				
				monster[:count] = monster[:count] +1;
				
				#echo "adding " + loot.name + " type " + type + " to current list with count of " +  monster[:count].to_s
				
				tmpFrom = lootFrom.to_s ||= "None"
				
				#echo "From: " + tmpFrom + " Loot: " + loot.name + " Type: " + type + " Count: " +  monster[:count].to_s
			
				found=true;
			end
		}
		CharSettings.save
		unless found then
			#echo "unless found: " + loot.name + " type: " + type + " count: 1"
			
			tmpFrom = lootFrom.to_s ||= "None"
			
			#echo "From: " + tmpFrom + " Loot: " + loot.name + " Type: " + type + " Count: 1"
			
			CharSettings['lootlist'].push(h={:from=>lootFrom,:name=>loot.name,:type=>type,:count=>1})
			CharSettings.save
		end
	end 
	
	

    disk = nil

    if type == 'box' and settings['enable_disking'] and $sloot_has_disk and not $sloot_disk_full
        unless disk = check_for_disk.call
            msg.call("I can't seem to find your disk")
            $sloot_has_disk = false

            if Char.prof == 'Wizard' and Spell[511].known? and Char.level > 10
                msg.call("Hooray! You're a Weezard!")

                if Spell[511]
                    Spell[511].cast
                    disk = check_for_disk.call
                else
                    msg.call("No mana, aborting.")
                end
            end
        end
    end

    unless sack = sacks[type]
        msg.call("unable to find sack for \"#{loot.name}\" with type \"#{loot.type}\"")
        msg.call("to loot manually, ;p #{script.name}")
        msg.call("you have 5 seconds to pause me")
        fput "look in ##{loot.id}"
        sleep 5
        next
    end

    unless get_item.call(loot, nil)
        msg.call("failed to get item \"#{loot.name}\" from \"#{sack.name}\"")
    else
        if disk and put_item.call(loot,disk)
            next
        elsif type == 'box' and settings['enable_phasing'] and Spell[704].known? and Spell[704].affordable? and Char.level > 3 and loot.name !~ /mithril|enruned/
            right_hand = GameObj.left_hand.id == loot.id 

            dothistimeout "prep 704", 5, /Phase/
            res = dothistimeout "cast ##{loot.id}", 5, /somewhat insubstantial|flickers in and out|becomes momentarily|resists the effects/

            # phased items get a different id so refresh the loot GameObj
            if res =~ /becomes momentarily/
                if right_hand
                    wait_while { GameObj.right_hand.noun.nil? }
                    loot = GameObj.right_hand
                else
                    wait_while { GameObj.left_hand.noun.nil? }
                    loot = GameObj.left_hand
                end
            end
        end

        unless put_item.call(loot, sack)
            result = false
            settings['overflowsack'].split(',').each { |overflow|
                if put_item.call(loot,overflow)
                    sacks[type] = GameObj.inv.find { |obj| obj.name =~ /\b#{Regexp.escape(overflow.strip)}/i }
                    result = true
                    break
                end
            }

            unless result
                msg.call("failed to put item \"#{loot.name}\" in sack \"#{sack.name}\" or overflow containers")
                fput "drop ##{loot.id}"
            end
        end
    end
}

# Frees up the loot hand
free_hand = proc {
    next if checkleft.nil? or checkright.nil?

    if UserVars.lootsack.nil?
        msg.call("warning: attempting to empty hand using lich function but no loostack has been set")
    end

    if settings['enable_stow_left']
        empty_left_hand
    else
        empty_right_hand
    end
}

# Loots a single GameObj or an array of GameObjs
loot_it = proc { |array, exclude, fromCreature|

    next if array.nil?
    unless array.class == Array
        array = [ array ]
    end

	dropSource = fromCreature.to_s ||= nil
	#(X)
	echo "dropSource == " + fromCreature.to_s
	
	#echo "array: " + array.to_s
	
    if CharSettings['loot_exclude'].to_s.length > 0
        array.delete_if { |loot| loot.name =~ /#{CharSettings['loot_exclude']}/ }
    end

	
    array.each { |loot|
	
        next if loot.name =~ /severed.*(?:arm|leg)/

        # Skip over any loot that is in the exclude array
        if exclude.include?(loot.id)
            exclude.delete(loot.id)
            next
        end

        # Make sure that the loot type is something we want to pickup
        if loot.type.split(',').any? { |type| settings["enable_loot_#{type}"] }
            free_hand.call() unless GameObj.right_hand.id == loot.id or GameObj.left_hand.id == loot.id
            
			#(X)
			#grab_loot.call(loot, nil)
			grab_loot.call(loot, dropSource)
			
			#[CSV Code From]-GSIV:Ryaden
			
			require 'csv'

			experimentarray = [[Char.name, Char.level.to_s, Time.now.to_s, Room.current.id.to_s, Room.current.location, loot.id.to_s, loot.name,loot.type.to_s,"","","","","",critterList.to_s]]

			CSV.open("experiment.csv", "a+") do |csv|
				experimentarray.each do |obj|
					csv << obj
				end
			end					
			
        elsif loot.name == 'some silver coins'
            dothistimeout "get ##{loot.id}", 5, /^You gather the remaining \d+ coins from inside your .*\.$|^You gather the remaining/
        end	
		
    }
}

# Checks a bundle for ammo type
check_bundle = proc { |id|
    ammo_name = settings['ammo_name'].strip
    result = nil

    action = proc { |server_string|
        line = server_string
        if server_string =~ /Individual projectiles from this bundle will have a (?:show|long) of "(.*)"|Each individual projectile will be "(.*)"/
            name_long = $1
            name_short = $2

            if name_long =~ /.*#{ammo_name}/ or name_short =~ /.*#{ammo_name}/
                result = server_string
            end
            nil
        elsif server_string =~ /^You carefully count|Individual/
            nil
        elsif server_string.strip.empty?
            nil
        elsif server_string =~ /<prompt time=/
            result = false if result.nil?
            DownstreamHook.remove("sloot_check_bundle")
            nil
        else
            server_string
        end
    }

    DownstreamHook.add("sloot_check_bundle", action)
    $_SERVER_.puts "#{$cmd_prefix}look at ##{id}\n"
    wait_while { result.nil? }

    result
}

# Gets bundle information for ammo
get_bundle_details = proc do |bundle|
    details = {
        :id => bundle.id
    }

    put "look at ##{bundle.id}"
    while line = get
        if line =~ /a strength of (\d+) and a durability of (\d+)/
            details[:strength] = $1.to_i
            details[:durability] = $2.to_i
        elsif line =~ /Each individual projectile will be "([^"]+)"\./
            details[:name] = $1.to_s
            break
        end
    end

    details
end

# Gathers ammunition
gather_ammo = proc do
    next unless settings['enable_gather']

    ammo_name = settings['ammo_name'].strip
    quiver = GameObj.inv.find { |obj| obj.name =~ /#{UserVars.ammosack}/ }

    if quiver.nil?
        echo "failed to gather: you must specify an ammo container to use this feature"
        next
    end

    if ammo_name.nil? or ammo_name.empty?
        echo "failed to gather: you must specify the ammo name to use this feature"
        next
    end

    ammo_noun = nil
    if ammo_name =~ /\b(bolt|arrow|dart)\b/
        ammo_noun = $1.to_s
    else
        echo "failed to gather: unknown arrow noun"
    end

    bundles = quiver.contents.find_all do |loot|
        loot.type == 'ammo' and 
        loot.name =~ /bundle/i
    end

    $sloot_bundles ||= []
    $sloot_bundles.delete_if { |sb| not quiver.contents.find { |item| item.id == sb[:id] } }

    bundles.each do |bundle|
        if $sloot_bundles.find { |sb| sb[:id] == bundle.id }
            next
        end

        $sloot_bundles.push(get_bundle_details.call(bundle))
    end

    ammo = GameObj.loot.find_all do |loot|
        loot.type == 'ammo' and
        loot.name =~ /\b#{ammo_name}s?\b/
    end

    if ammo.length > 0
        # gather ammo first
        res = dothistimeout "gather #{ammo_noun}", 2, /The bolt is out of your reach\.|You gather|You pick up/

        if res =~ /You gather/
            sleep 0.2 until GameObj.right_hand.id
        end
    end

    if GameObj.right_hand.name =~ /#{ammo_noun}s/i
        details = get_bundle_details.call(GameObj.right_hand)
        bundle = $sloot_bundles.find { |bundle| bundle[:name] == details[:name] }

        if bundle
            fput "put ##{details[:id]} in ##{bundle[:id]}"
        end
    elsif GameObj.right_hand.name =~ /#{ammo_name}/i
        bundle = $sloot_bundles.find { |bundle| bundle[:name] =~ /#{GameObj.right_hand.name}/i }

        if bundle
            fput "put ##{GameObj.right_hand.id} in ##{bundle[:id]}"
        end
    else
    end
end

# Locksmithing routine
locksmith = proc { |boxes, silver_breakdown|
    empty_hands
    withdraw_coins.call(10000)
    go2.call('locksmith')

    unless trash = GameObj[/crate|barrel|wastebarrel|casket/]
        msg.call('unable to locate trash')
    end

    # FWI: Try and find activator first.
    activator = GameObj[/chime/]

    if activator.nil?
        unless table = GameObj[/table|counter/]
            msg.call('unable to find table')
            next
        end

        unless table.contents
            dothistimeout "look on ##{table.id}", 5, /On the/

            unless table.contents
                msg.call("failed to find contents of #{table.name}")
                next
            end
        end

        unless activator = table.contents.find { |o| o.noun =~ /bell|keys|chime/ }
            msg.call('unable to find activator')
        end
    end

    case activator.noun
        when /bell|chime/
            activator = "ring ##{activator.id}"
        when /keys/
            activator = 'pull keys'
    end

    if settings['enable_disking'] and $sloot_has_disk
        unless disk = GameObj[/^.*#{Char.name} (?:disk|coffin)$/]
            unless disk = check_for_disk.call
                msg.call("failed to find a disk")
            end
        end
    end

    open_box = proc { |box|
        get_item.call(box,nil)

=begin
        unless [2425].include? Room.current.id
            res = dothistimeout "put ##{box.id} on ##{table.id}", 5, /^You put|^You should really/

            # Phasing for those Sorcerer types (evil bastards!)
            if res =~ /^You should really/
                dothistimeout "drop ##{box.id}", 5, /flickers in and out of existence/
                put_item.call(box,table.id)
            end
        end
=end

        # properly handle phased items
        if box.name =~ /shifting/i
            right_hand = GameObj.left_hand.id == box.id 

            res = dothistimeout "drop ##{box.id}", 5, /flickers in and out of existence/

            if res =~ /flickers in and out of existence/
                if right_hand
                    wait_while { GameObj.right_hand.noun.nil? }
                    box = GameObj.right_hand
                else
                    wait_while { GameObj.left_hand.noun.nil? }
                    box = GameObj.left_hand
                end
            end
        end

        res = dothistimeout activator, 5, /but it'll cost ya\.  Gimme (\d+) silvers/
        if res =~ /Gimme (\d+) silvers/
            box_cost = $1.to_i
        else
            box_cost = 0
            msg.call("unknown locksmith response: " + res.to_s)
        end

        res = dothistimeout "pay", 5, /accepts|have enough/
        if res =~ /have enough/
            put_item.call(box,UserVars.boxsack)
            withdraw_coins.call(10000)
            next open_box.call(box)
        end

        silver_breakdown['locksmith'] ||= 0
        silver_breakdown['locksmith'] = silver_breakdown['locksmith'].to_i - box_cost

        cur_silvers = checksilvers.call

        dothistimeout "open ##{box.id}", 5, /open/
        unless box.contents
            dothistimeout "look in ##{box.id}", 5, /^In the/

            unless box.contents
                msg.call("failed to see contents of #{box.name}")
				echo "loot_it 0"
                loot_it.call(box,nil,nil)
                next
            end
        end

		echo "loot_it 1"
        loot_it.call(box.contents,nil,nil)
        silver_breakdown['locksmith'] = silver_breakdown['locksmith'] + (checksilvers.call - cur_silvers)
        unless trash.nil?
            unless put_item.call(box,trash.id)
                dothistimeout "drop ##{box.id}", 5, /drop/ if [checkleft,checkright].include?(box.noun)
            end
        end

        dothistimeout "drop ##{box.id}", 5, /drop/ if [checkleft,checkright].include?(box.noun)
    }

    dothistimeout "unhide", 5, /hiding|visible/ if invisible? or hiding?
    done = []
    boxes.each { |b|
        next if done.include? b.id

        open_box.call(b)
        done.push(b.id)
    }
}

to_locker = proc {
    if checksilvers.call < 1000
        withdraw_coins.call(1000)
    end
    go2.call(CharSettings['locker'])

    CharSettings['locker_in'].split(',').each do |cmd| 
        move cmd
    end

    if way_in = (GameObj.loot.to_a + GameObj.room_desc.to_a).find { |obj| obj.noun =~ /^(?:opening|curtain)$/ }
        move "go #{way_in.noun}"
    else
        echo "error: failed to find locker entrance"
    end
}

from_locker = proc {
    if way_out = (GameObj.loot.to_a + GameObj.room_desc.to_a).find { |obj| obj.noun =~ /^(?:opening|curtain)$/ }
        move "go #{way_out.noun}"
    else
        echo "error: failed to find locker exit"
    end

    CharSettings['locker_out'].split(',').each do |cmd|
        move cmd
    end
}

need_to_stockpile = proc {
    if CharSettings[:jars].any? { |jar| jar[:gem] =~ /large|medium|small|tiny/ }
        CharSettings[:jars] = nil
    end
    lootsack = sacks['gem']
    can_start_new_jar = (CharSettings[:empty_jar_count] > 0) and lootsack.contents.any? { |obj| (obj.type =~ /gem/) and (obj.name !~ /oblivion quartz$/) and not CharSettings[:jars].any? { |jar| jar[:gem] =~ /^#{obj.name.gsub(/large |medium |small |tiny |some /, '').sub(/y\b/, '(?:y|ie)').sub(/z\b/, 'ze?').gsub(/\b\s/, 's? ')}s?$/ } }
    can_add_to_jar = CharSettings[:jars].any? { |jar| !jar[:full] and lootsack.contents.any? { |obj| jar[:gem] =~ /^#{obj.name.gsub(/large |medium |small |tiny |some /, '').sub(/y\b/, '(?:y|ie)').sub(/z\b/, 'ze?').gsub(/\b\s/, 's? ')}s?$/ } }
    CharSettings[:jars].nil? or can_start_new_jar or can_add_to_jar
}

need_to_raid_stockpile = proc {
    if checkbounty =~ /gem dealer.* requesting (?:a|an|some) (.*?)\. .* retrieve ([0-9]+) (?:more )?of them\./
        gem = $1
        count = $2.to_i
        CharSettings[:jars].any? { |jar| (jar[:gem] =~ /^#{gem.gsub(/large |medium |small |tiny |some /, '').sub(/y\b/, '(?:y|ie)').sub(/z\b/, 'ze?').gsub(/\b\s/, 's? ')}s?$/) and (jar[:count] >= count) }
    else
        false
    end
}

stockpile = proc {
    status_tags
    lootsack = sacks['gem']
    open_result = dothistimeout 'open locker', 5, /exist=".*?" noun="(?:locker|chest)"/
    status_tags
    if open_result =~ /exist="(\d+)" noun="(locker|chest)"/
        locker_id = $1
        locker_contents = GameObj.containers[locker_id]
        unless locker_contents
            dothistimeout "look in ##{locker_id}", 3, /^In the/
            locker_contents = GameObj.containers[locker_id]
        end
        if locker_contents
            if CharSettings[:jars].nil?
                CharSettings[:jars] = Array.new
                CharSettings[:empty_jar_count] = 0
                locker_contents.find_all { |obj| obj.noun =~ /^(?:jar|bottle|beaker)$/ }.each { |jar|
                    if jar.after_name.nil?
                        CharSettings[:empty_jar_count] = CharSettings[:empty_jar_count] + 1
                    else
                        look_result = dothistimeout "look in ##{jar.id} from ##{locker_id}", 3, /^Inside .*? you see [0-9]+ portion/
                        if look_result =~ /^Inside .*? you see ([0-9]+) portion/
                            count = $1.to_i
                            gem = jar.after_name.gsub(/^containing |large |medium |small |tiny |some /, '')
                            full = look_result.include?('It is full')
                            CharSettings[:jars].push(h={ :gem => gem, :count => count, :full => full })
                        end
                    end
                }
            end
            empty_hands
            not_suitable = Array.new
            for jar in locker_contents.find_all { |obj| obj.noun =~ /^(?:jar|beaker|bottle)$/ }
                if jar.after_name =~ /^containing /
                    gem_list = lootsack.contents.find_all { |obj| (jar.after_name.gsub(/^containing |large |medium |small |tiny |some /, '') =~ /^#{obj.name.gsub(/large |medium |small |tiny |some /, '').sub(/y\b/, '(?:y|ie)').sub(/z\b/, 'ze?').gsub(/\b\s/, 's? ')}s?$/) }
                    gem_list.delete_if { |obj| not_suitable.include?(obj.id) }
                    jar_hash = CharSettings[:jars].find { |j| j[:gem] == jar.after_name.gsub(/^containing |large |medium |small |tiny |some /, '') }
                    unless gem_list.empty? or jar_hash[:full]
                        dothistimeout "get ##{jar.id} from ##{locker_id}", 3, /^You remove/
                        for gem in gem_list
                            result = dothistimeout "_drag ##{gem.id} ##{jar.id}", 3, /^You add|is full|does not appear to be a suitable container for/
                            if result =~ /^You add .* filling it/
                                jar_hash[:count] = jar_hash[:count] + 1
                                jar_hash[:full] = true
                            elsif result =~ /^You add/
                                jar_hash[:count] = jar_hash[:count] + 1
                            elsif result =~ /is full/
                                jar_hash[:full] = true
                                dothistimeout "put ##{gem.id} in ##{lootsack.id}", 3, putregex
                                break
                            elsif result =~ /does not appear to be a suitable container for/
                                dothistimeout "put ##{gem.id} in ##{lootsack.id}", 3, putregex
                                not_suitable.push(gem.id)
                            else
                                dothistimeout "put ##{gem.id} in ##{lootsack.id}", 3, putregex
                            end
                        end
                        dothistimeout "put ##{jar.id} in ##{locker_id}", 3, /^You (?:put|place)/
                    end
                else
                    gem_count = Hash.new
                    lootsack.contents.each { |obj|
                        if (obj.type =~ /gem/) and (obj.name !~ /oblivion quartz$/) and not locker_contents.any? { |o| o.after_name.gsub(/^containing |large |medium |small |tiny |some /, '') =~ /^#{obj.name.gsub(/large |medium |small |tiny |some /, '').sub(/y\b/, '(?:y|ie)').sub(/z\b/, 'ze?').gsub(/\b\s/, 's? ')}s?$/ and not not_suitable.include?(obj.id) }
                            gem_count[obj.name.gsub(/large |medium |small |tiny |some /, '')] = gem_count[obj.name.gsub(/large |medium |small |tiny |some /, '')].to_i + 1
                        end
                    }
                    next if gem_count.empty?
                    gem_name = nil
                    gem_num = 0
                    gem_count.each_pair { |name,num|
                        if num > gem_num
                            gem_name = name
                            gem_num = num
                        end
                    }
                    dothistimeout "get ##{jar.id} from ##{locker_id}", 3, /^You remove/
                    jar_hash = nil
                    lootsack.contents.each { |obj|
                        if obj.name.gsub(/large |medium |small |tiny |some /, '') == gem_name
                            result = dothistimeout "_drag ##{obj.id} ##{jar.id}", 3, /^You (?:add|put)|is full|does not appear to be a suitable container for/
                            if result =~ putregex
                                dothistimeout "put ##{jar.id} in ##{lootsack.id}", 3, putregex
                                gem = lootsack.contents.find { |obj| obj.id == jar.id }.after_name.gsub(/^containing |large |medium |small |tiny |some /, '')
                                dothistimeout "get ##{jar.id}", 3, /^You remove/
                                jar_hash = { :gem => gem, :count => 1, :full => false }
                                CharSettings[:jars].push(jar_hash)
                            elsif result =~ /^You add/
                                jar_hash[:count] = jar_hash[:count] + 1
                            elsif result =~ /is full/
                                dothistimeout "put ##{obj.id} in ##{lootsack.id}", 3, putregex
                                jar_hash[:full] = true
                                break
                            elsif result =~ /does not appear to be a suitable container for/
                                not_suitable.push(obj.id)
                                fput "put ##{obj.id} in ##{lootsack.id}"
                            end
                        end
                    }
                    dothistimeout "put ##{jar.id} in ##{locker_id}", 3, /^You (?:put|place)/
                end
            end
            dothistimeout "close locker", 3, /^You close|^That is already closed\.$/
            fill_hands
        else
            dothistimeout "close locker", 3, /^You close|^That is already closed\.$/
            echo 'error: failed to find locker contents'
        end
    else
        dothistimeout "close locker", 3, /^You close|^That is already closed\.$/
        echo 'error: failed to find locker'
    end
}

raid_stockpile = proc {
    lootsack = sacks['gem']
    if bounty? =~ /gem dealer .* requesting (?:a|an|some) (.*?)\. .* retrieve ([0-9]+) (?:more )?of them\./
        gem = $1
        count = $2.to_i
        gem.gsub!(/large |medium |small |tiny |some /, '')
        status_tags
        open_result = dothistimeout 'open locker', 5, /exist=".*?" noun="(?:locker|chest)"/
        status_tags
        if open_result =~ /exist="(\d+)" noun="(locker|chest)"/
            locker_id = $1
            locker_contents = GameObj.containers[locker_id]
            unless locker_contents
                dothistimeout "look in ##{locker_id}", 3, /^In the/
                locker_contents = GameObj.containers[locker_id]
            end
            if locker_contents
                if CharSettings[:jars].any? { |jar| (jar[:gem] =~ /^#{gem.gsub(/large |medium |small |tiny |some /, '').sub(/y\b/, '(?:y|ie)').sub(/z\b/, 'ze?').gsub(/\b\s/, 's? ')}s?$/) and (jar[:count] >= count) }
                    if jar = locker_contents.find { |jar| jar.after_name.gsub(/^containing |large |medium |small |tiny |some /, '') =~ /^#{gem.gsub(/large |medium |small |tiny |some /, '').sub(/y\b/, '(?:y|ie)').sub(/z\b/, 'ze?').gsub(/\b\s/, 's? ')}s?$/ }
                        jar_hash = CharSettings[:jars].find { |j| j[:gem] == jar.after_name.sub(/^containing |large |medium |small |tiny |some /, '') }
                        empty_hands
                        dothistimeout "get ##{jar.id} from ##{locker_id}", 3, /^You remove/
                        count.times {
                            dothistimeout "shake ##{jar.id}", 3, /^You .*shake/
                            if GameObj.right_hand.id != jar.id
                                obj = GameObj.right_hand
                            elsif GameObj.left_hand.id != jar.id
                                obj = GameObj.left_hand
                            end
                            dothistimeout "put ##{obj.id} in ##{lootsack.id}", 3, putregex
                            jar_hash[:count] = jar_hash[:count] - 1
                            jar_hash[:full] = false
                        }
                        dothistimeout "put ##{jar.id} in ##{locker_id}", 3, /^You (?:put|place)/
                        if jar_hash[:count] < 1
                            CharSettings[:jars].delete(jar_hash)
                            CharSettings[:empty] = CharSettings[:empty] + 1
                        end
                        fill_hands
                        dothistimeout "close locker", 3, /^You close|^That is already closed\.$/
                        true
                    else
                        dothistimeout "close locker", 3, /^You close|^That is already closed\.$/
                        false
                    end
                else
                    dothistimeout "close locker", 3, /^You close|^That is already closed\.$/
                    false
                end
            else
                dothistimeout "close locker", 3, /^You close|^That is already closed\.$/
                echo 'error: failed to find locker contents'
                false
            end
        else
            dothistimeout "close locker", 3, /^You close|^That is already closed\.$/
            echo 'error: failed to find locker'
            false
        end
    else
        echo "error: you're doing it wrong"
        false
    end
}

# Lockering boxes routine
locker_boxes = proc { |boxes|
    to_locker.call()

    status_tags
    open_result = dothistimeout 'open locker', 5, /exist=".*?" noun="(?:locker|chest)"/
    if !open_result
        echo "error: failed to find locker to open"
        next
    end
    status_tags

    if open_result !~ /exist="(\d+)" noun="(locker|chest)"/
        echo "error: failed to find locker id"
        exit
    end

    locker_id = $1.to_s

    boxes.each do |box|
        fput "get ##{box.id}"
        res = dothistimeout "put ##{box.id} in locker", 3, /in the locker, and it quickly disappears\./
        if res !~ /in the locker/ or GameObj.right_hand.id == box.id or GameObj.left_hand.id == box.id
            $sloot_locker_full = true
			
			echo "loot_it 2"
            loot_it.call(GameObj.right_hand) if checkright
            loot_it.call(GameObj.left_hand) if checkleft
            break
        end
    end

    fput "close locker"

    from_locker.call()
}

# Sell routine
sell = proc {
    cur_room         = Room.current.id
    found_sacks      = Array.new
    selling          = Hash.new
    silver_breakdown = Hash.new
    types            = Array.new

    # Chronomage
    if settings['enable_sell_chronomage']
        sack  = GameObj[UserVars.jewelrysack]
        rings = sack.contents.find_all { |item| item.name =~ /^(\w+) gold ring$/ }
        if not rings.empty?
            go2.call('chronomage')
            npc = GameObj.npcs.first

            if not npc.nil?
                empty_hands

                rings.each { |ring|
                    fput "get ##{ring.id}"
                    fput "give ##{ring.id} to ##{npc.id}"

                    if checkleft or checkright
                        fput "put ##{ring.id} in my ##{sack.id}"
                    end
                }

                fill_hands
            end
        end
    end

    find_boxes = proc {
        box_sacks = [GameObj[UserVars.boxsack]]
        boxes     = []

        settings['overflowsack'].split(',').each { |sack|
            if found_sack = GameObj[sack]
                box_sacks.push(found_sack)
            end
        }

        box_sacks.each { |sack|
            if (more_boxes = sack.contents.find_all { |o| o.type.include?('box') })
                boxes += more_boxes
            end
        }

        if settings['enable_disking'] and $sloot_has_disk
            unless disk = GameObj[/^.*#{Char.name} (?:disk|coffin)$/]
                unless disk = check_for_disk.call
                    msg.call("failed to find a disk")
                end
            end

            if disk
                unless disk.contents
                    dothistimeout "look in ##{disk.id}", 5, /There is nothing|In the .*?/
                    unless disk.contents
                        msg.call("failed to find contents of your disk")
                    end
                end

                boxes += disk.contents.find_all { |o| o.type.include?('box') }.to_a if disk.contents
            end
        end

        boxes
    }

    boxes = find_boxes.call

    # Lockering boxes
    if boxes.size > 0 and settings['enable_locker_boxes'] and not $sloot_locker_full
        locker_boxes.call(boxes)
        boxes = find_boxes.call
    end

    # Locksmith
    if boxes.size > 0 and settings['enable_sell_locksmith']
        locksmith.call(boxes, silver_breakdown)
    end

    # Stockpile gems
    if settings['enable_sell_stockpile']
        if CharSettings['locker'].nil?
            echo 'warning: stockpiling is turned on but locker room is not set'
            sleep 3
        elsif need_to_stockpile.call or need_to_raid_stockpile.call
            if to_locker.call
                stockpile.call if need_to_stockpile.call
                raid_stockpile.call if need_to_raid_stockpile.call
                from_locker.call
            end
        end
    end

    settings.keys.each { |key|
        if key =~ /^enable_sell_type_(.*)$/
            type = $1
            types.push(type) if settings[key]

            if found_sack = GameObj[UserVars.send("#{type}sack")]
                found_sacks.push(found_sack) unless found_sacks.include?(found_sack)
            end
        end
    }

    settings['overflowsack'].split(',').each { |sack|
        if found_sack = GameObj[sack]
            found_sacks.push(found_sack) unless found_sacks.include?(found_sack)
        end
    }

    found_sacks.each { |sack|
        unless sack.contents
            dothistimeout "look in ##{sack.id}", 5, /In the .*?/
            unless sack.contents
                msg.call("-- failed to find contents of sack: #{sack.name}")
                next
            end
        end

        sack.contents.each { |item|
            if CharSettings['sell_exclude'].to_s.length > 0
                next if item.name =~ /#{CharSettings['sell_exclude']}/
                next if item.name =~ /Guild voucher pack/i
            end
            unless item.sellable.nil?
                if item.type.split(',').any? { |type| type =~ /^#{types.join('|')}$/ }
                    selling[item.sellable] ||= Array.new
                    selling[item.sellable].push(item)
                end
            end
        }
    }

    # sell empty boxes
    if settings['enable_sell_type_empty_box']
        box_sacks = [GameObj[UserVars.boxsack]]
        box_sacks.each { |sack|
            if (more_boxes = sack.contents.find_all { |o| o.type.include?('box') })
                more_boxes.each { |box|
                    selling["pawnshop"] ||= Array.new
                    selling["pawnshop"].push(box)
                }
            end
        }
    end

    # sell scarabs as gems
    if settings['enable_sell_type_scarab']
        if (more_scarabs = GameObj[UserVars.boxsack].contents.find_all { |o| o.type.include?('scarab') })
            more_scarabs.each { |scarab|
                selling["gemshop"] ||= Array.new
                selling["gemshop"].push(scarab)
            }
        end
    end

    sell_item = proc { |item|
        if get_item.call(item,nil)
            dothistimeout "sell ##{item.id}", 5, /ask|offer/

            if checkleft == item.noun or checkright == item.noun
                unless put_item.call(item,UserVars.send("#{item.type.split(',').first}sack"))
                    dothistimeout "drop ##{item.id}", 5, /drop/
                end
            end
        else
            msg.call("-- failed to find #{item.name}")
            exit
        end
    }

    if selling.size == 0
        msg.call("-- nothing to sell")
    else
        empty_hands

        selling.each_pair { |location,items|
            start_silvers = checksilvers.call

            location = location.split(',').first
            go2.call(location)
            items.each { |item| sell_item.call(item) }

            silver_breakdown[location] = checksilvers.call - start_silvers
        }
    end

    deposit_coins.call()
    go2.call(cur_room)
    fill_hands

    unless silver_breakdown.empty?
        msg.call("silver breakdown")
        silver_breakdown.each_pair { |location, silver|
            msg.call("#{location.split(',').first}: #{silver}")
        }

        total_made = silver_breakdown.values.inject { |i,j| i + j }
        msg.call("total: #{total_made}")
    end
}

# Returns an array of all dead npcs using GameObj
find_dead = proc { |type|
    npcs = GameObj.npcs.find_all { |npc| npc.status == 'dead' }

    if CharSettings['critter_exclude'].to_s.length > 0
        npcs.delete_if { |npc| npc.name =~ /#{CharSettings['critter_exclude']}/ }
    end

    npcs
}

# Checks if it's safe to enhance skinning by kneeling or stancing to offensive
safe_to_enhance = proc {
    next true unless settings['enable_skin_safe_mode']
    !GameObj.npcs.any? { |npc| npc.status !~ /dead/ }
}

# Prepares for skinning process
prepare_skinner = proc { |critter|
    next if settings['skin_exclude'].include?(critter.name)
    next if skin_prepared
    next unless GameObj.npcs.any? { |npc| npc.status =~ /dead/ }
    next unless settings['enable_skinning']

    # Sigil of Resolve
    if Spell[9704].known? and Spell[9704].affordable? and not Spell[9704].active? and settings['enable_skin_sigil']
        Spell[9704].cast
    end

    # 604 - Skinning
    if Spell[604].known? and Spell[604].affordable? and settings['enable_skin_604']
        while !Spell[604].active?
            Spell[604].cast
        end
    end

    if settings['enable_skin_alternate']
        if critter.name =~ /krag dweller|greater krynch|massive boulder/
            empty_hands
            skin_empty_hands = true
        else
            free_hand.call
        end

        skinweaponcurrent = skinweapon
        if critter.name =~ /krynch|spiked cavern urchin|krag dweller|stone mastiff|gargoyle|massive boulder/i and UserVars.skinweaponblunt.to_s.length > 1
            skinweaponcurrent = skinweaponblunt
        end

        unless get_item.call(skinweaponcurrent,sacks['skinweapon'])
            msg.call("** failed to find #{skinweaponcurrent.name} in #{sacks['skinweapon'].name}")
        end
    else
        if critter.name =~ /krag dweller|greater krynch|massive boulder/
            free_hand.call
        end
    end

    if safe_to_enhance.call
        while settings['enable_skin_kneel'] and !checkkneeling
            dothistimeout "kneel", 5, /^You kneel down\.$|^You move to|^You are already kneeling\.$/
        end

        if settings['enable_skin_offensive']
            change_stance.call('offensive')
        end
    end

    skin_prepared = true
}

# Get thee up!
stand_up = proc {
    if settings['skin_stand_verb'].nil? or settings['skin_stand_verb'].empty?
        until standing?
            dothistimeout "stand", 5, /^You stand back up\.$/
        end
    else
        until standing?
            fput settings['skin_stand_verb']
        end
    end
}

# Finishes up skinning process
finish_skinner = proc {
    next unless skin_prepared
    next unless settings['enable_skinning']

    if settings['enable_skin_stance_first']
        change_stance.call(prev_stance)
        stand_up.call
    else
        stand_up.call
        change_stance.call(prev_stance)
    end

    if settings['enable_skin_alternate']
        unless put_item.call(skinweaponcurrent, UserVars.skinweaponsack)
            echo "failed to put #{skinweaponcurrent} in #{UserVars.skinweaponsack}"
        end
    end

    if skin_empty_hands
        fill_hands
        skin_empty_hands = false
    end
}

# Skins a critter
skin_critter = proc { |critter|
    next if settings['skin_exclude'].include?(critter.name)

    cmd = "skin ##{critter.id}"
    if not skinweaponcurrent.nil? and checkleft =~ /#{skinweaponcurrent}/i
        cmd += " with ##{GameObj.left_hand.id}"
    end

    res = dothistimeout cmd, 5, /skinned|botched|already been|cannot skin|must be a member|can only skin|You are unable to break through|You break through the crust of the|You crack open a portion/
    if res =~ /^You cannot skin/
        settings['skin_exclude'].push(critter.name)
    elsif res =~ /^(?:You break through the crust of the .+ and withdraw |You crack open a portion of the .+ and uncover )(.+)!/
        foundgem = $1.split.last
        gemsack = GameObj.inv.find { |obj| obj.name =~ /#{UserVars.gemsack}/}
        put_item.call(foundgem,gemsack)
    end
}

# Retrieves the previously stored item
get_stored = proc {
    if settings['enable_stow_left']
        fill_left_hand
        $fill_left_hand_actions = Array.new
    else
        fill_right_hand
        $fill_right_hand_actions = Array.new
    end
}

['clothing', 'ammo', 'box', 'gem', 'herb', 'jewelry', 'lockpick', 'magic', 'reagent', 'scroll', 'skin', 'uncommon', 'wand', 'skinweapon', 'valuable'].each { |type|
    if !UserVars.send("#{type}sack").nil? and UserVars.send("#{type}sack").length > 0 and sack = GameObj.inv.find { |obj| obj.name =~ /\b#{Regexp.escape(UserVars.send("#{type}sack").strip)}/i }
        sacks[type] = sack
    elsif script.vars[1] !~ /^setup/i
        next if type == 'skinweapon' && !settings['enable_skinning']
        next if !settings["enable_loot_#{type}"]
        echo "** failed to find #{type} sack"
        exit
    end
}

if script.vars[1] =~  /^reset-gui$/i
    settings['window_height'] = nil
    settings['window_width'] = nil
    settings['window_position'] = nil

    echo "gui reset"
elsif script.vars[1] =~ /^stockpile-forget$/i
    CharSettings[:jars] = nil
    echo 'stockpile cleared'
elsif script.vars[1] =~ /^stockpile-list$/i
    output = "                           gem count  full\n"
    output.concat "                           --- -----  ----\n"

    gem = script.vars[2]
    for jar in CharSettings[:jars].sort { |a,b| b[:count] <=> a[:count] }
        if gem.nil? or jar[:gem] =~ /#{gem}/
            output.concat "#{jar[:gem].rjust(30)} #{jar[:count].to_s.rjust(2)} #{jar[:full].to_s.rjust(8)}\n"
        end
    end
    respond output
elsif script.vars[1] =~ /^deposit$/i
    deposit_coins.call
elsif script.vars[1] =~ /^sell$/i
    sell.call
elsif script.vars[1] =~  /^setup$/i
    setup.call
elsif script.vars[1] =~ /^(right|left)$/i
    hand = $1 == 'right' ? GameObj.right_hand : GameObj.left_hand
    unless hand.contents
        dothistimeout "look in ##{hand.id}", 5, /^I could not find|In the .*\.$/
        unless hand.contents
            msg.call("failed to find contents of #{hand.name}")
        end
    end

	echo "loot_it 3"
    loot_it.call(hand.contents,nil)
elsif script.vars[1] =~  /^(?:help|\?)$/
    msg.call( sprintf('SLoot'))
    msg.call( sprintf('%17s: SpiffyJr &lt;spiffyjr@gmail.com&gt;', 'Author'))
    msg.call( sprintf('%17s: SLoot is designed to be the most versatile looter available!', 'Description'))
    msg.call( sprintf('%17s: ;sloot - runs the skin, search, and loot routine on the current room.', 'Usage'))
    respond
    msg.call( sprintf('%17s     %s', 'help, ?', 'show this help message'))
    msg.call( sprintf('%17s     %s', 'setup', 'run the GUI configuration'))
    msg.call( sprintf('%17s     %s', 'reset-gui', 'resets the GUI window if it gets lost'))
    respond
    msg.call( sprintf('%17s     %s', 'stockpile-forget', 'forget your stockpile settings'))
    msg.call( sprintf('%17s     %s', 'stockpile-list', 'lists your stockpiled gems'))
    respond
    msg.call( sprintf('%17s     %s', 'dump', 'dumps the current settings to the screen'))
    respond
    msg.call( sprintf('%17s     %s', 'sell', 'runs the automated selling routine'))
    msg.call( sprintf('%17s     %s', 'deposit', 'deposits your coins according to settings'))
    respond
    msg.call( sprintf('%17s     %s', 'sack', 'runs sloot on the sack specified'))
    msg.call( sprintf('%17s     %s', 'left', 'runs sloot on the sack in your left hand'))
    msg.call( sprintf('%17s     %s', 'right', 'runs sloot on the sack in your right hand'))
end

exit unless script.vars[1].nil?

if settings['enable_skinning'] and settings['enable_skin_alternate']
    skinweaponsack  = sacks['skinweapon']

    if skinweaponsack.nil?
        echo "** skinning is enabled but I could not find your skin weapon sack"
        exit
    end

    if not sacks['skinweapon'].contents
        fput "look in ##{sacks['skinweapon'].id}"
    end

    skinweapon      = skinweaponsack.contents.find { |obj| obj.name =~ /\b#{Regexp.escape(UserVars.skinweapon)}/i }
    skinweaponblunt = skinweaponsack.contents.find { |obj| obj.name =~ /\b#{Regexp.escape(UserVars.skinweaponblunt)}/i }

    if skinweapon.nil?
        echo "** skinning is enabled but I could not find your skin weapon"
    end

    if skinweaponblunt.nil?
        skinweaponblunt = skinweapon
    end
end

if settings['enable_locker_boxes'] and not settings['locker']
    echo '** lockering boxes is enabled but your locker is not set'
    exit
end

# Hooks for disk tracking and statistics
install_hooks.call

# Is safe hiding enabled?
if settings['enable_safe_hiding'] and hiding?
    bad_npcs = GameObj.npcs.find_all { |npc|
        npc.type !~ /escort/ and npc.status !~ /dead/ and npc.name !~ /^(?:#{settings['safe_ignore'].to_s})$/
    }
    exit if bad_npcs.length > 0
end

# Keep track of loot IDs in the current room if we're only looting our critter drops
previous_loot_ids = Array.new
if settings['enable_self_drops']
    previous_loot_ids = GameObj.loot.collect { |l| l.id }
end

critters = find_dead.call

if settings['enable_skinning']
    critters.each { |critter|
        next if critter.name =~ /Grimswarm/ or critter.type =~ /bandit/
        prepare_skinner.call(critter)
        skin_critter.call(critter)
    }
    finish_skinner.call
end

# fuck the bramble patch, seriously
critters.delete_if { |critter| critter.name =~ /\b(?:shrub|plant|tumbleweed|creeper)\b/ }

npcs = GameObj.npcs.find_all { |npc| npc.status == 'dead' }

npcs.each { |npc| 

 #(X)
 #echo "---------------"
 #echo npc.name
 #echo "---------------"
 
 critterLevel = 0
 
 creature_list.find{|critter, level|
	if npc.name=~/#{critter}/ then
		#echo "found critter, #{critter} level #{level}"
		#echo "---------------"
		critterLevel = level
	end
 }
 

 
	if CharSettings['killlist'].nil?
		#echo npc.to_s
		CharSettings['killlist']=Array.new
		CharSettings['killlist'].push(h={:name=>npc.name,:level=>critterLevel,:count=>1})
		echo "Creature: " + npc.name + " Level: " + critterLevel.to_s + " Count: 1"
		kill_list=CharSettings['killlist']
		CharSettings.save
		
		#[CSV Code From]-GSIV:Ryaden

		require 'csv'

		experimentarray = [[Char.name, Char.level.to_s, Time.now.to_s, Room.current.id.to_s, Room.current.location,npc.id.to_s,"","",npc.name,critterLevel.to_s,1]]

		CSV.open("experiment.csv", "a+") do |csv|
		experimentarray.each do |obj|
		csv << obj
		end
		end

	else
		found=false
		CharSettings['killlist'].each{|monster|
			if monster[:name]==npc.name then
				
				monster[:count] = monster[:count] +1;
				
				#echo "adding " + npc.name + " level " + critterLevel.to_s + " to current list with count of " +  monster[:count].to_s
				
				echo "Creature: " + npc.name + " Level: " + critterLevel.to_s + " Count: " +  monster[:count].to_s
			
			
				#[CSV Code From]-GSIV:Ryaden

				require 'csv'

				experimentarray = [[Char.name, Char.level.to_s, Time.now.to_s, Room.current.id.to_s, Room.current.location,npc.id.to_s,"","",npc.name,critterLevel.to_s,monster[:count].to_s]]

				CSV.open("experiment.csv", "a+") do |csv|
				experimentarray.each do |obj|
				csv << obj
				end
				end			
			
				found=true;
			end
		}
		CharSettings.save
		unless found then
			#echo "unless found: " + npc.name + " level: " + critterLevel.to_s + " count: 1"
			echo "Creature: " + npc.name + " Level: " + critterLevel.to_s + " Count: 1"
			CharSettings['killlist'].push(h={:name=>npc.name,:level=>critterLevel,:count=>1})
			CharSettings.save
			
			#[CSV Code From]-GSIV:Ryaden

			require 'csv'

			experimentarray = [[Char.name, Char.level.to_s, Time.now.to_s, Room.current.id.to_s, Room.current.location,npc.id.to_s,"","",npc.name,critterLevel.to_s,1]]

			CSV.open("experiment.csv", "a+") do |csv|
			experimentarray.each do |obj|
			csv << obj
			end
			end				
			
		end
	end 

}

critterList = ""

critters.each { |critter|

	if critterList == "" then
		critterList = critter
	else
		critterList = critterList + " - " + critter.to_s
	end
	

	#(X)
	echo "    Searching critter > " + critter.to_s
	
    res = dothistimeout "search ##{critter.id}", 5, /^You search (?:through )?the .*\.$|^What were you referring to|You plunge your hand|and withdraw a fiery red gem!|causing assorted foliage to fall|You quickly grab the/

    if res =~ /withdraw a (?:cold blue gem|fiery red gem)/
        #righthand == 'gem' ? loot_it.call(GameObj.right_hand, []) : loot_it.call(GameObj.left_hand, [])
		
		echo "loot_it 4"
		echo "     critters > hand check 1 "
		righthand == 'gem' ? loot_it.call(GameObj.right_hand, nil, critter.name) : loot_it.call(GameObj.left_hand, nil, critter)
		
    elsif res =~ /you withdraw your arm to find a pungent piece/
        #righthand == 'caederine' ? loot_it.call(GameObj.right_hand, []) : loot_it.call(GameObj.left_hand, [])
		
		echo "loot_it 5"
		echo "     critters > hand check 2 "
		righthand == 'caederine' ? loot_it.call(GameObj.right_hand, nil, critter.name) : loot_it.call(GameObj.left_hand, nil, critter)
    end

    # Bramble patch lewt
    if righthand =~ /berry|thorn/
        fput 'stow right'
    elsif lefthand =~ /berry|thorn/
        fput 'stow left'
    end

    break unless settings['enable_search_all']
}

if script.vars[1] =~ /^left$/i
    target = [GameObj.left_hand]
elsif script.vars[1] =~ /^right$/i
    target = [GameObj.right_hand]
else
    target = GameObj.loot
end

if settings['enable_stance_on_start']
    change_stance.call('defensive')
end

#echo "loot_it 6"
#echo "target: " + target.to_s
loot_it.call(target,previous_loot_ids,critterList.to_s)
gather_ammo.call()

get_stored.call()
close_open_sacks.call()

$fill_hand_actions = Array.new
$fill_left_hand_actions = Array.new
$fill_right_hand_actions = Array.new
